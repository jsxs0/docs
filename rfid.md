This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-12-12T07:08:40.070Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
ClientApp/
  src/
    components/
      Login.tsx
      Register.tsx
      RFIDHandler.tsx
    contexts/
      AuthContext.tsx
    rfid/
      V680RFIDHandler.ts
    styles/
      auth.css
      rfidHandler.css
    types/
      api/
        core/
          ApiError.ts
          ApiRequestOptions.ts
          ApiResult.ts
          AxiosHttpRequest.ts
          BaseHttpRequest.ts
          CancelablePromise.ts
          OpenAPI.ts
          request.ts
        models/
          Error.ts
          ForgotPasswordRequest.ts
          LoginRequest.ts
          LoginResponse.ts
          RefreshTokenRequest.ts
          RegisterRequest.ts
          ResetPasswordRequest.ts
          RFIDReadRequest.ts
          RFIDWriteRequest.ts
          User.ts
        services/
          AuthenticationService.ts
          RfidService.ts
        index.ts
        RFIDApi.ts
      react.d.ts
    utils/
      axios.ts
      serial.ts
    App.tsx
    index.css
    main.tsx
    RFIDHandler.tsx
    vite-env.d.ts
  .env.development
  .env.production
  .eslintrc.cjs
  .node-version
  index.html
  package.json
  tsconfig.json
  tsconfig.node.json
  vite.config.ts
prisma/
  migrations/
    20241011090817_update_user_schema/
      migration.sql
    20241029060101_add_role_field/
      migration.sql
    migration_lock.toml
  schema.prisma
server/
  lib/
    prisma.ts
  rfid/
    V680RFIDHandler.ts
  routes/
    auth.ts
    index.ts
    rfid.ts
  services/
    EmailService.ts
  server.ts
tests/
  __mocks__/
    mockRFIDHandler.ts
    serialport.ts
    V680RFIDHandler.ts
  auth.test.ts
  rfid.test.ts
  setup.ts
.gitignore
global_rate_test.sh
jest.config.js
nodemon.json
openapi.yml
package.json
password_reset_test.sh
README.md
tsconfig.json
tsconfig.node.json
types.d.ts

================================================================
Repository Files
================================================================

================
File: ClientApp/src/components/Login.tsx
================
import React, { useState } from "react";
import { Form, Input, Button, Card, Typography, message } from "antd";
import { useAuth } from "../contexts/AuthContext";
import { useNavigate } from "react-router-dom";
import type { FormProps } from "antd";
import "../styles/auth.css";

const { Link } = Typography;

interface LoginFormValues {
  username: string;
  password: string;
}

const Login: React.FC = () => {
  const { login } = useAuth();
  const navigate = useNavigate();
  const [form] = Form.useForm<LoginFormValues>();
  const [loading, setLoading] = useState(false);

  const onFinish: FormProps<LoginFormValues>["onFinish"] = async (values) => {
    setLoading(true);
    try {
      await login(values.username, values.password);
      navigate("/");
    } catch (error) {
      console.error("Login error:", error);
      message.error("ログインに失敗しました");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="auth-container">
      <Card className="auth-card" bordered={false}>
        <h1 className="auth-title">ログイン</h1>
        <Form<LoginFormValues>
          form={form}
          name="login"
          onFinish={onFinish}
          layout="vertical"
        >
          <Form.Item
            label="ユーザー名"
            name="username"
            rules={[
              { required: true, message: "ユーザー名を入力してください" },
            ]}
          >
            <Input 
              autoComplete="username" 
              size="large"
              disabled={loading}
            />
          </Form.Item>

          <Form.Item
            label="パスワード"
            name="password"
            rules={[
              { required: true, message: "パスワードを入力してください" },
            ]}
          >
            <Input.Password 
              autoComplete="current-password" 
              size="large"
              disabled={loading}
            />
          </Form.Item>

          <Form.Item>
            <Button 
              type="primary" 
              htmlType="submit" 
              block
              loading={loading}
            >
              ログイン
            </Button>
          </Form.Item>
        </Form>
        <div style={{ textAlign: 'center', marginTop: '16px' }}>
          <Link href="/register">
            アカウントを作成する
          </Link>
        </div>
      </Card>
    </div>
  );
};

export default Login;

================
File: ClientApp/src/components/Register.tsx
================
import React, { useState } from "react";
import { Form, Input, Button, Card, Typography, message } from "antd";
import { useNavigate } from "react-router-dom";
import type { FormProps } from "antd";
import "../styles/auth.css";
import axiosInstance from "../utils/axios";

const { Link } = Typography;

interface RegisterFormValues {
  username: string;
  email: string;
  password: string;
  confirmPassword: string;
  companyName?: string;
  branch?: string;
  division?: string;
  title?: string;
  telephoneNumber?: string;
}

const Register: React.FC = () => {
  const navigate = useNavigate();
  const [form] = Form.useForm<RegisterFormValues>();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(false);

  const onFinish: FormProps<RegisterFormValues>["onFinish"] = async (values) => {
    setLoading(true);
    setError(false);
    try {
      await axiosInstance.post("/auth/register", {
        username: values.username,
        email: values.email,
        password: values.password,
        companyName: values.companyName,
        branch: values.branch,
        division: values.division,
        title: values.title,
        telephoneNumber: values.telephoneNumber,
      });

      message.success("アカウントが作成されました");
      navigate("/login");
    } catch (error) {
      console.error("Registration error:", error);
      message.error("アカウントの作成に失敗しました");
      setError(true);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="auth-container">
      <Card className="auth-card" bordered={false}>
        <h1 className="auth-title">アカウントを作成する</h1>
        <Form<RegisterFormValues>
          form={form}
          name="register"
          onFinish={onFinish}
          layout="vertical"
          className={`auth-form ${error ? 'form-error' : ''}`}
        >
          <Form.Item
            label="ユーザー名"
            name="username"
            rules={[
              { required: true, message: "ユーザー名を入力してください" },
              { min: 3, message: "ユーザー名は3文字以上である必要があります" },
            ]}
          >
            <Input 
              autoComplete="username" 
              size="large"
              disabled={loading}
            />
          </Form.Item>

          <Form.Item
            label="メールアドレス"
            name="email"
            rules={[
              { required: true, message: "メールアドレスを入力してください" },
              { type: "email", message: "有効なメールアドレスを入力してください" },
            ]}
          >
            <Input 
              autoComplete="email" 
              size="large"
              disabled={loading}
            />
          </Form.Item>

          <Form.Item
            label="パスワード"
            name="password"
            rules={[
              { required: true, message: "パスワードを入力してください" },
              { min: 8, message: "パスワードは8文字以上である必要があります" },
            ]}
          >
            <Input.Password 
              autoComplete="new-password" 
              size="large"
              disabled={loading}
            />
          </Form.Item>

          <Form.Item
            label="パスワードの確認"
            name="confirmPassword"
            dependencies={["password"]}
            rules={[
              { required: true, message: "パスワードを再入力してください" },
              ({ getFieldValue }) => ({
                validator(_, value) {
                  if (!value || getFieldValue("password") === value) {
                    return Promise.resolve();
                  }
                  return Promise.reject(new Error("パスワードが一致しません"));
                },
              }),
            ]}
          >
            <Input.Password 
              autoComplete="new-password" 
              size="large"
              disabled={loading}
            />
          </Form.Item>

          <Form.Item label="会社名" name="companyName">
            <Input size="large" disabled={loading} />
          </Form.Item>

          <Form.Item label="支店" name="branch">
            <Input size="large" disabled={loading} />
          </Form.Item>

          <Form.Item label="部署" name="division">
            <Input size="large" disabled={loading} />
          </Form.Item>

          <Form.Item label="役職" name="title">
            <Input size="large" disabled={loading} />
          </Form.Item>

          <Form.Item label="電話番号" name="telephoneNumber">
            <Input size="large" disabled={loading} />
          </Form.Item>

          <Form.Item>
            <Button 
              type="primary" 
              htmlType="submit" 
              block
              loading={loading}
              className="auth-button"
            >
              登録
            </Button>
          </Form.Item>
        </Form>
        <div style={{ textAlign: "center", marginTop: "16px" }}>
          <Link href="/login" className="auth-link">
            既にアカウントをお持ちの方はこちら
          </Link>
        </div>
      </Card>
    </div>
  );
};

export default Register;

================
File: ClientApp/src/components/RFIDHandler.tsx
================
import React, { useState, useCallback } from "react";
import { Button, Input, Typography, message, Alert, Spin } from "antd";
import { V680RFIDHandler, RFIDOperationResult } from "../rfid/V680RFIDHandler";
import { RfidService } from "../types/api/services/RfidService";
import { OpenAPI } from "../types/api/core/OpenAPI";
import { ApiError } from "../types/api/core/ApiError";
import { AxiosHttpRequest } from "../types/api/core/AxiosHttpRequest";
import "../styles/rfidHandler.css";

const { Text } = Typography;

interface Props {
  auth: {
    refreshToken: () => Promise<boolean>;
    logout: () => Promise<void>;
  };
}

export const RFIDHandler: React.FC<Props> = ({ auth }) => {
  const [rfidHandler] = useState(() => new V680RFIDHandler());
  const [rfidService] = useState(
    () =>
      new RfidService(
        new AxiosHttpRequest({
          BASE: OpenAPI.BASE,
          VERSION: OpenAPI.VERSION,
          WITH_CREDENTIALS: OpenAPI.WITH_CREDENTIALS,
          CREDENTIALS: OpenAPI.CREDENTIALS,
          TOKEN: OpenAPI.TOKEN,
          USERNAME: OpenAPI.USERNAME,
          PASSWORD: OpenAPI.PASSWORD,
          HEADERS: OpenAPI.HEADERS,
          ENCODE_PATH: OpenAPI.ENCODE_PATH,
        })
      )
  );

  const [connected, setConnected] = useState(false);
  const [readData, setReadData] = useState("");
  const [writeData, setWriteData] = useState("");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string>();
  const [retrying, setRetrying] = useState(false);

  const handleConnect = useCallback(async () => {
    try {
      const isConnected = await rfidHandler.connect();
      setConnected(isConnected);
      if (isConnected) {
        message.success("接続に成功しました");
      }
    } catch (error) {
      message.error("接続に失敗しました");
      setConnected(false);
    }
  }, [rfidHandler]);

  const handleApiError = useCallback(
    async (error: unknown) => {
      if (error instanceof ApiError && error.status === 401) {
        try {
          const refreshResult = await auth.refreshToken();
          if (!refreshResult) {
            message.error("認証エラー: もう一度ログインしてください");
            await auth.logout();
          }
        } catch (refreshError) {
          console.error("Token refresh error:", refreshError);
          message.error("認証エラー: もう一度ログインしてください");
          await auth.logout();
        }
      } else {
        message.error(
          `操作エラー: ${
            error instanceof Error ? error.message : String(error)
          }`
        );
      }
    },
    [auth]
  );

  const handleRead = useCallback(async () => {
    setLoading(true);
    setError(undefined);
    setRetrying(false);

    try {
      const result = await rfidHandler.readData();

      if (result.success && result.data !== -1) {
        if (result.attempts > 1) {
          message.warning(`Read succeeded after ${result.attempts} attempts`);
        }

        const response = await rfidService.postRead({
          tagId: result.data,
        });

        setReadData(response.data || "");
        setWriteData(response.data || "");
        message.success("データの読み取りに成功しました");
      } else if (result.data === -1) {
        message.error("RFIDの読み取りに問題が発生しました。");
        setError("RFIDの読み取りに問題が発生しました。");
      } else {
        const errorMessage = result.error?.message || "Unknown error occurred";
        if (result.error?.retryable) {
          message.error(
            `読み取りに失敗しました (${errorMessage}) - 再試行可能`
          );
        } else {
          message.error(`読み取りに失敗しました (${errorMessage})`);
        }
        setError(errorMessage);
      }
    } catch (error) {
      console.error("Read error:", error);
      await handleApiError(error);
    } finally {
      setLoading(false);
      setRetrying(false);
    }
  }, [rfidHandler, rfidService, handleApiError]);

  const handleWrite = useCallback(async () => {
    if (!writeData) {
      message.error("書き込むデータを入力してください");
      return;
    }

    setLoading(true);
    setError(undefined);
    setRetrying(false);

    try {
      const result = await rfidHandler.writeData(writeData);

      if (result.success) {
        if (result.attempts > 1) {
          message.warning(`Write succeeded after ${result.attempts} attempts`);
        }
        message.success("データの書き込みに成功しました");
        setWriteData("");
      } else {
        const errorMessage = result.error?.message || "Unknown error occurred";
        if (result.error?.retryable) {
          message.error(
            `書き込みに失敗しました (${errorMessage}) - 再試行可能`
          );
        } else {
          message.error(`書き込みに失敗しました (${errorMessage})`);
        }
        setError(errorMessage);
      }
    } catch (error) {
      console.error("Write error:", error);
      await handleApiError(error);
    } finally {
      setLoading(false);
      setRetrying(false);
    }
  }, [rfidHandler, writeData, handleApiError]);

  return (
    <div className="main-container rfid-handler">
      {error && (
        <Alert
          message="エラー"
          description={error}
          type="error"
          showIcon
          closable
          className="error-alert"
        />
      )}

      <Button
        type={connected ? "primary" : "default"}
        onClick={handleConnect}
        size="large"
        className="connect-button"
      >
        {connected ? "接続済み" : "接続"}
      </Button>

      {connected && (
        <>
          <div className="action-container">
            <Spin spinning={loading && retrying}>
              <Button
                onClick={handleRead}
                size="large"
                className="action-button"
                loading={loading && !retrying}
                disabled={retrying}
              >
                読み取り
              </Button>
            </Spin>
            <div className="read-result">
              <Text strong>データ: {readData}</Text>
            </div>
          </div>

          <div className="action-container">
            <Input
              placeholder="書き込むデータを入力（10進数）"
              value={writeData}
              onChange={(e) => setWriteData(e.target.value)}
              size="large"
              className="write-input"
              disabled={loading}
            />
            <Spin spinning={loading && retrying}>
              <Button
                onClick={handleWrite}
                size="large"
                className="action-button"
                loading={loading && !retrying}
                disabled={retrying}
              >
                書き込み
              </Button>
            </Spin>
          </div>
        </>
      )}
    </div>
  );
};

================
File: ClientApp/src/contexts/AuthContext.tsx
================
import React, { createContext, useContext, useState, useEffect } from "react";
import { message } from "antd";

interface User {
  id: number;
  username: string;
  email: string;
  companyName?: string;
  branch?: string;
  division?: string;
  title?: string;
  telephoneNumber?: string;
}

interface AuthContextType {
  user: User | null;
  login: (username: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  isAuthenticated: boolean;
  refreshToken: () => Promise<boolean>;
  checkTokenExpiration: () => boolean;
}

const AuthContext = createContext<AuthContextType | null>(null);
const API_BASE_URL = import.meta.env.VITE_API_URL || "http://localhost:3000";

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const [user, setUser] = useState<User | null>(null);
  const [isAuthenticated, setIsAuthenticated] = useState<boolean>(false);
  const [storedRefreshToken, setStoredRefreshToken] = useState<string | null>(
    localStorage.getItem("refreshToken")
  );

  const checkTokenExpiration = () => {
    const resetTokenExpiry = localStorage.getItem("resetTokenExpiry");
    const token = localStorage.getItem("token");

    if (resetTokenExpiry && token) {
      const expiryDate = new Date(resetTokenExpiry);
      if (new Date() > expiryDate) {
        return false;
      }
    }
    return true;
  };

  useEffect(() => {
    const checkAuth = async () => {
      const token = localStorage.getItem("token");
      if (!token) {
        setIsAuthenticated(false);
        setUser(null);
        return;
      }

      if (!checkTokenExpiration()) {
        await logout();
        return;
      }

      try {
        const response = await fetch(`${API_BASE_URL}/auth/check`, {
          method: "GET",
          credentials: "include",
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });

        if (response.ok) {
          const data = await response.json();
          setUser(data.user);
          setIsAuthenticated(true);
        } else {
          const refreshResult = await refreshToken();
          if (!refreshResult) {
            await logout();
          }
        }
      } catch (error) {
        console.error("Auth check error:", error);
        setIsAuthenticated(false);
        setUser(null);
      }
    };

    checkAuth();
  }, []);

  useEffect(() => {
    const checkAuthStatus = () => {
      const isValid = checkTokenExpiration();
      if (!isValid && isAuthenticated) {
        logout();
        message.error(
          "セッションの有効期限が切れました。再度ログインしてください。"
        );
      }
    };

    const interval = setInterval(checkAuthStatus, 60000);

    return () => {
      clearInterval(interval);
    };
  }, [isAuthenticated]);

  const getCsrfToken = async () => {
    try {
      const response = await fetch(`${API_BASE_URL}/auth/csrf-token`, {
        method: "GET",
        credentials: "include",
        headers: {
          "Accept": "application/json",
        }
      });
      
      if (!response.ok) {
        console.warn("Failed to get CSRF token, continuing without it");
        return null;
      }
      
      const data = await response.json();
      return data.csrfToken;
    } catch (error) {
      console.warn("CSRF token error:", error);
      return null;
    }
  };

  const login = async (username: string, password: string) => {
    try {
      const csrfToken = await getCsrfToken();
      const headers: Record<string, string> = {
        "Content-Type": "application/json",
      };

      if (csrfToken) {
        headers["X-CSRF-Token"] = csrfToken;
      }

      const response = await fetch(`${API_BASE_URL}/auth/login`, {
        method: "POST",
        credentials: "include",
        headers,
        body: JSON.stringify({ username, password }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || "Login failed");
      }

      const data = await response.json();
      localStorage.setItem("token", data.token);
      localStorage.setItem("refreshToken", data.refreshToken);
      if (data.resetTokenExpiry) {
        localStorage.setItem("resetTokenExpiry", data.resetTokenExpiry);
      }
      setStoredRefreshToken(data.refreshToken);
      setUser(data.user);
      setIsAuthenticated(true);
      message.success("ログインしました");
    } catch (error) {
      console.error("Login error:", error);
      message.error("ログインに失敗しました");
      throw error;
    }
  };

  const refreshToken = async () => {
    if (!storedRefreshToken) {
      return false;
    }

    try {
      const response = await fetch(`${API_BASE_URL}/auth/refresh-token`, {
        method: "POST",
        credentials: "include",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ refreshToken: storedRefreshToken }),
      });

      if (!response.ok) {
        throw new Error("トークンの更新に失敗しました");
      }

      const data = await response.json();
      localStorage.setItem("token", data.token);
      setUser(data.user);
      setIsAuthenticated(true);
      return true;
    } catch (error) {
      console.error("Token refresh error:", error);
      return false;
    }
  };

  const logout = async () => {
    try {
      const csrfToken = await getCsrfToken();

      await fetch(`${API_BASE_URL}/auth/logout`, {
        method: "POST",
        credentials: "include",
        headers: {
          "X-CSRF-Token": csrfToken,
        },
      });
    } catch (error) {
      console.error("Logout error:", error);
    } finally {
      localStorage.removeItem("token");
      localStorage.removeItem("refreshToken");
      localStorage.removeItem("resetTokenExpiry");
      setStoredRefreshToken(null);
      setUser(null);
      setIsAuthenticated(false);
    }
  };

  return (
    <AuthContext.Provider
      value={{
        user,
        login,
        logout,
        isAuthenticated,
        refreshToken,
        checkTokenExpiration,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
};

================
File: ClientApp/src/rfid/V680RFIDHandler.ts
================
import { SerialConnection } from "../utils/serial";

const RFID_COMMANDS = {
  READ_DATA: "RDH1001010*",
  WRITE_PREFIX: "WTH10010",
  WRITE_SUFFIX: "*\r",
  WRITE_SUCCESS_PREFIX: "WT00",
} as const;

const MAX_DECIMAL_VALUE = BigInt("18446744073709551615");
const HEX_LENGTH = 4;
const READ_RESPONSE_PREFIX = "RD00";
const BYTES_LENGTH = 2;

const RFID_ERROR_CODES = {
  WRITE_FAILED: "WRITE_FAILED",
  UNEXPECTED_RESPONSE: "UNEXPECTED_RESPONSE",
  DEVICE_BUSY: "DEVICE_BUSY",
  INVALID_RESPONSE: "INVALID_RESPONSE",
} as const;

const ERROR_MESSAGES = {
  INVALID_NUMBER: "数値の形式が正しくありません",
  OUT_OF_RANGE: "入力可能な範囲を超えています",
  CONVERSION_ERROR: "数値の変換に失敗しました",
  DEVICE_BUSY: "デバイスがビジー状態です",
  UNEXPECTED_RESPONSE: "予期しない応答を受信しました",
  MAX_RETRIES: "最大試行回数を超えました",
} as const;

interface RFIDOperationResult<T> {
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
    retryable: boolean;
  };
  attempts: number;
}

export class V680RFIDHandler {
  private serial: SerialConnection;
  private readonly MAX_RETRIES = 3;
  private readonly RETRY_DELAY = 1000;

  constructor() {
    this.serial = new SerialConnection();
  }

  async connect(): Promise<boolean> {
    return await this.serial.connect();
  }

  private async retry<T>(
    operation: () => Promise<T>,
    operationName: string
  ): Promise<RFIDOperationResult<T>> {
    let attempts = 0;

    while (attempts < this.MAX_RETRIES) {
      attempts++;
      try {
        const data = await operation();
        return { success: true, data, attempts };
      } catch (error) {
        const isRetryable = this.isRetryableError(error);

        if (!isRetryable || attempts === this.MAX_RETRIES) {
          return {
            success: false,
            error: {
              code: this.getErrorCode(error),
              message: this.getErrorMessage(error),
              retryable: isRetryable,
            },
            attempts,
          };
        }

        await new Promise((resolve) =>
          setTimeout(resolve, this.RETRY_DELAY * attempts)
        );
        console.log(
          `Retrying ${operationName} operation (attempt ${attempts + 1}/${
            this.MAX_RETRIES
          })`
        );
      }
    }

    return {
      success: false,
      error: {
        code: "MAX_RETRIES_EXCEEDED",
        message: `Operation failed after ${this.MAX_RETRIES} attempts`,
        retryable: false,
      },
      attempts,
    };
  }

  async readData(): Promise<RFIDOperationResult<number>> {
    return this.retry(async () => {
      try {
        const response = await this.serial.sendCommand(RFID_COMMANDS.READ_DATA);

        if (!response || !response.includes(READ_RESPONSE_PREFIX)) {
          return 0;
        }

        const dataHex = response.substring(
          response.indexOf(READ_RESPONSE_PREFIX) + READ_RESPONSE_PREFIX.length,
          response.indexOf(READ_RESPONSE_PREFIX) +
            READ_RESPONSE_PREFIX.length +
            4
        );

        if (!dataHex || /^0+$/.test(dataHex)) {
          return 0;
        }

        return this.hexToDecimal(dataHex);
      } catch (error) {
        console.warn(
          "RFIDの読み取りに問題が発生しました。-1を返します:",
          error
        );
        return -1;
      }
    }, "read");
  }

  async writeData(data: string): Promise<RFIDOperationResult<void>> {
    return this.retry(async () => {
      try {
        const number = BigInt(data);
        if (number < BigInt(0) || number > MAX_DECIMAL_VALUE) {
          throw new Error(ERROR_MESSAGES.OUT_OF_RANGE);
        }

        const hexString = number.toString(16).padEnd(4, "0").toUpperCase();
        const command = `${RFID_COMMANDS.WRITE_PREFIX}${hexString}${RFID_COMMANDS.WRITE_SUFFIX}`;

        const response = await this.serial.sendCommand(command);
        if (!response.startsWith(RFID_COMMANDS.WRITE_SUCCESS_PREFIX)) {
          throw new Error(`予期しない書き込み応答: ${response}`);
        }
      } catch (error) {
        if (
          error instanceof Error &&
          error.message === ERROR_MESSAGES.OUT_OF_RANGE
        ) {
          throw error;
        }
        throw new Error(ERROR_MESSAGES.CONVERSION_ERROR);
      }
    }, "write");
  }

  private hexToDecimal(hex: string): number {
    try {
      const cleanHex = hex.replace(/[^0-9A-Fa-f]/g, "").slice(0, HEX_LENGTH);
      if (!cleanHex || /^0+$/.test(cleanHex)) {
        return 0;
      }
      return Number(BigInt(`0x${cleanHex}`));
    } catch (error) {
      console.warn("16進数の変換に問題が発生しました。-1を返します:", error);
      return -1;
    }
  }

  async disconnect(): Promise<void> {
    await this.serial.disconnect();
  }

  private isRetryableError(error: any): boolean {
    if (error instanceof Error && error.message.includes("WT14")) {
      return true;
    }

    const retryableErrors = [
      RFID_ERROR_CODES.DEVICE_BUSY,
      RFID_ERROR_CODES.UNEXPECTED_RESPONSE,
    ];

    return retryableErrors.includes(this.getErrorCode(error));
  }

  private getErrorCode(error: any): string {
    if (error instanceof Error) {
      if (error.message.includes("WT14")) {
        return RFID_ERROR_CODES.DEVICE_BUSY;
      }
      if (error.message.includes("予期しない書き込み応答")) {
        return RFID_ERROR_CODES.UNEXPECTED_RESPONSE;
      }
      return error.name || RFID_ERROR_CODES.WRITE_FAILED;
    }
    return RFID_ERROR_CODES.WRITE_FAILED;
  }

  private getErrorMessage(error: any): string {
    if (error instanceof Error) {
      return error.message;
    }
    return String(error);
  }
}

================
File: ClientApp/src/styles/auth.css
================
.auth-container {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  background-color: #f0f2f5;
}

.auth-card {
  width: 400px;
  animation: slideUp 0.5s ease-out, float 6s ease-in-out infinite;
  -webkit-animation: slideUp 0.5s ease-out, float 6s ease-in-out infinite;
  transform-origin: center;
  -webkit-transform-origin: center;
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  background: rgba(255, 255, 255, 0.9) !important;
  border-radius: 15px !important;
  box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
}

.auth-title {
  text-align: center;
  margin-bottom: 24px;
  background: linear-gradient(90deg, #333, #777, #333);
  background-size: 200% auto;
  color: #000;
  background-clip: text;
  -webkit-background-clip: text;
  animation: shine 3s linear infinite;
  -webkit-animation: shine 3s linear infinite;
}

/* Input field animations */
.auth-card .ant-input,
.auth-card .ant-input-password {
  transition: all 0.3s ease;
  -webkit-transition: all 0.3s ease;
  border-radius: 8px;
}

.auth-card .ant-input:focus,
.auth-card .ant-input-password:focus {
  transform: scale(1.02);
  -webkit-transform: scale(1.02);
  box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
}

.auth-card .ant-form-item-has-error .ant-input,
.auth-card .ant-form-item-has-error .ant-input-password {
  animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
  -webkit-animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
}

/* Login button animations */
.auth-card .ant-btn {
  transition: all 0.3s ease;
  -webkit-transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
  border-radius: 8px;
  background: linear-gradient(45deg, #2196F3, #00BCD4);
}

.auth-card .ant-btn:hover:not(:disabled) {
  transform: scale(1.02);
  -webkit-transform: scale(1.02);
  animation: pulse 1.5s infinite;
  -webkit-animation: pulse 1.5s infinite;
  background: linear-gradient(45deg, #00BCD4, #2196F3);
}

.auth-card .ant-btn:active::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 300px;
  height: 300px;
  background: rgba(255, 255, 255, 0.4);
  border-radius: 50%;
  transform: translate(-50%, -50%) scale(0);
  -webkit-transform: translate(-50%, -50%) scale(0);
  animation: ripple 0.6s linear;
  -webkit-animation: ripple 0.6s linear;
}

/* Link animation */
.auth-card .ant-typography {
  transition: all 0.3s ease;
  -webkit-transition: all 0.3s ease;
  position: relative;
}

.auth-card .ant-typography:hover {
  opacity: 0.8;
  text-shadow: 0 0 8px rgba(0, 0, 0, 0.2);
}

.auth-card .ant-typography::after {
  content: '';
  position: absolute;
  width: 100%;
  height: 2px;
  bottom: -2px;
  left: 0;
  background: linear-gradient(90deg, transparent, #1890ff, transparent);
  transform: scaleX(0);
  -webkit-transform: scaleX(0);
  transition: transform 0.3s ease;
  -webkit-transition: -webkit-transform 0.3s ease;
}

.auth-card .ant-typography:hover::after {
  transform: scaleX(1);
  -webkit-transform: scaleX(1);
}

/* Keyframe Animations */
@keyframes slideUp {
  0% {
    opacity: 0;
    transform: translateY(20px);
  }
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

@-webkit-keyframes slideUp {
  0% {
    opacity: 0;
    -webkit-transform: translateY(20px);
  }
  100% {
    opacity: 1;
    -webkit-transform: translateY(0);
  }
}

@keyframes pulse {
  0% {
    box-shadow: 0 0 0 0 rgba(24, 144, 255, 0.4);
  }
  70% {
    box-shadow: 0 0 0 6px rgba(24, 144, 255, 0);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(24, 144, 255, 0);
  }
}

@-webkit-keyframes pulse {
  0% {
    box-shadow: 0 0 0 0 rgba(24, 144, 255, 0.4);
  }
  70% {
    box-shadow: 0 0 0 6px rgba(24, 144, 255, 0);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(24, 144, 255, 0);
  }
}

@keyframes float {
  0%, 100% {
    transform: translateY(0);
  }
  50% {
    transform: translateY(-10px);
  }
}

@-webkit-keyframes float {
  0%, 100% {
    -webkit-transform: translateY(0);
  }
  50% {
    -webkit-transform: translateY(-10px);
  }
}

@keyframes shine {
  to {
    background-position: 200% center;
  }
}

@-webkit-keyframes shine {
  to {
    background-position: 200% center;
  }
}

@keyframes shake {
  10%, 90% {
    transform: translate3d(-1px, 0, 0);
  }
  20%, 80% {
    transform: translate3d(2px, 0, 0);
  }
  30%, 50%, 70% {
    transform: translate3d(-4px, 0, 0);
  }
  40%, 60% {
    transform: translate3d(4px, 0, 0);
  }
}

@-webkit-keyframes shake {
  10%, 90% {
    -webkit-transform: translate3d(-1px, 0, 0);
  }
  20%, 80% {
    -webkit-transform: translate3d(2px, 0, 0);
  }
  30%, 50%, 70% {
    -webkit-transform: translate3d(-4px, 0, 0);
  }
  40%, 60% {
    -webkit-transform: translate3d(4px, 0, 0);
  }
}

@keyframes ripple {
  to {
    transform: translate(-50%, -50%) scale(4);
    opacity: 0;
  }
}

@-webkit-keyframes ripple {
  to {
    -webkit-transform: translate(-50%, -50%) scale(4);
    opacity: 0;
  }
}

================
File: ClientApp/src/styles/rfidHandler.css
================
/* Scoping all styles to the RFID handler component */
.rfid-handler .action-button {
  position: relative;
  transition: all 0.3s ease;
}

.rfid-handler .action-button:not(.ant-btn-loading):hover {
  transform: scale(1.05);
  box-shadow: 0 0 15px rgba(24, 144, 255, 0.4);
}

/* Pulse animation for read button */
.rfid-handler .action-button:not(.ant-btn-loading):active::after {
  content: "";
  position: absolute;
  top: 50%;
  left: 50%;
  width: 100%;
  height: 100%;
  transform: translate(-50%, -50%);
  border-radius: 2px;
  background-color: rgba(24, 144, 255, 0.6);
  animation: rfidPulse 0.6s ease-out;
}

@keyframes rfidPulse {
  0% {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
  }
  100% {
    transform: translate(-50%, -50%) scale(1.5);
    opacity: 0;
  }
}

/* Container styles */
.rfid-handler.main-container {
  padding: 20px;
  display: flex;
  flex-direction: column;
  gap: 20px;
  max-width: 600px;
  margin: 0 auto;
}

.rfid-handler .action-container {
  display: flex;
  align-items: center;
  gap: 16px;
}

.rfid-handler .connect-button {
  align-self: flex-start;
}

.rfid-handler .write-input {
  flex: 1;
}

.rfid-handler .read-result {
  flex: 1;
  padding: 8px;
  background-color: #f5f5f5;
  border-radius: 4px;
}

.rfid-handler .error-alert {
  margin-bottom: 20px;
  animation: slideIn 0.3s ease-out;
}

.rfid-handler .ant-spin {
  display: inline-block;
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.rfid-handler .action-container .ant-spin-spinning {
  padding: 8px;
  border-radius: 4px;
  background: rgba(255, 255, 255, 0.8);
}

================
File: ClientApp/src/types/api/core/ApiError.ts
================
/* generated using openapi-typescript-codegen -- do not edit */
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { ApiRequestOptions } from './ApiRequestOptions';
import type { ApiResult } from './ApiResult';

export class ApiError extends Error {
    public readonly url: string;
    public readonly status: number;
    public readonly statusText: string;
    public readonly body: any;
    public readonly request: ApiRequestOptions;

    constructor(request: ApiRequestOptions, response: ApiResult, message: string) {
        super(message);

        this.name = 'ApiError';
        this.url = response.url;
        this.status = response.status;
        this.statusText = response.statusText;
        this.body = response.body;
        this.request = request;
    }
}

================
File: ClientApp/src/types/api/core/ApiRequestOptions.ts
================
/* generated using openapi-typescript-codegen -- do not edit */
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export type ApiRequestOptions = {
    readonly method: 'GET' | 'PUT' | 'POST' | 'DELETE' | 'OPTIONS' | 'HEAD' | 'PATCH';
    readonly url: string;
    readonly path?: Record<string, any>;
    readonly cookies?: Record<string, any>;
    readonly headers?: Record<string, any>;
    readonly query?: Record<string, any>;
    readonly formData?: Record<string, any>;
    readonly body?: any;
    readonly mediaType?: string;
    readonly responseHeader?: string;
    readonly errors?: Record<number, string>;
};

================
File: ClientApp/src/types/api/core/ApiResult.ts
================
/* generated using openapi-typescript-codegen -- do not edit */
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export type ApiResult = {
    readonly url: string;
    readonly ok: boolean;
    readonly status: number;
    readonly statusText: string;
    readonly body: any;
};

================
File: ClientApp/src/types/api/core/AxiosHttpRequest.ts
================
/* generated using openapi-typescript-codegen -- do not edit */
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { ApiRequestOptions } from './ApiRequestOptions';
import { BaseHttpRequest } from './BaseHttpRequest';
import type { CancelablePromise } from './CancelablePromise';
import type { OpenAPIConfig } from './OpenAPI';
import { request as __request } from './request';

export class AxiosHttpRequest extends BaseHttpRequest {

    constructor(config: OpenAPIConfig) {
        super(config);
    }

    /**
     * Request method
     * @param options The request options from the service
     * @returns CancelablePromise<T>
     * @throws ApiError
     */
    public override request<T>(options: ApiRequestOptions): CancelablePromise<T> {
        return __request(this.config, options);
    }
}

================
File: ClientApp/src/types/api/core/BaseHttpRequest.ts
================
/* generated using openapi-typescript-codegen -- do not edit */
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { ApiRequestOptions } from './ApiRequestOptions';
import type { CancelablePromise } from './CancelablePromise';
import type { OpenAPIConfig } from './OpenAPI';

export abstract class BaseHttpRequest {

    constructor(public readonly config: OpenAPIConfig) {}

    public abstract request<T>(options: ApiRequestOptions): CancelablePromise<T>;
}

================
File: ClientApp/src/types/api/core/CancelablePromise.ts
================
/* generated using openapi-typescript-codegen -- do not edit */
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export class CancelError extends Error {

    constructor(message: string) {
        super(message);
        this.name = 'CancelError';
    }

    public get isCancelled(): boolean {
        return true;
    }
}

export interface OnCancel {
    readonly isResolved: boolean;
    readonly isRejected: boolean;
    readonly isCancelled: boolean;

    (cancelHandler: () => void): void;
}

export class CancelablePromise<T> implements Promise<T> {
    #isResolved: boolean;
    #isRejected: boolean;
    #isCancelled: boolean;
    readonly #cancelHandlers: (() => void)[];
    readonly #promise: Promise<T>;
    #resolve?: (value: T | PromiseLike<T>) => void;
    #reject?: (reason?: any) => void;

    constructor(
        executor: (
            resolve: (value: T | PromiseLike<T>) => void,
            reject: (reason?: any) => void,
            onCancel: OnCancel
        ) => void
    ) {
        this.#isResolved = false;
        this.#isRejected = false;
        this.#isCancelled = false;
        this.#cancelHandlers = [];
        this.#promise = new Promise<T>((resolve, reject) => {
            this.#resolve = resolve;
            this.#reject = reject;

            const onResolve = (value: T | PromiseLike<T>): void => {
                if (this.#isResolved || this.#isRejected || this.#isCancelled) {
                    return;
                }
                this.#isResolved = true;
                if (this.#resolve) this.#resolve(value);
            };

            const onReject = (reason?: any): void => {
                if (this.#isResolved || this.#isRejected || this.#isCancelled) {
                    return;
                }
                this.#isRejected = true;
                if (this.#reject) this.#reject(reason);
            };

            const onCancel = (cancelHandler: () => void): void => {
                if (this.#isResolved || this.#isRejected || this.#isCancelled) {
                    return;
                }
                this.#cancelHandlers.push(cancelHandler);
            };

            Object.defineProperty(onCancel, 'isResolved', {
                get: (): boolean => this.#isResolved,
            });

            Object.defineProperty(onCancel, 'isRejected', {
                get: (): boolean => this.#isRejected,
            });

            Object.defineProperty(onCancel, 'isCancelled', {
                get: (): boolean => this.#isCancelled,
            });

            return executor(onResolve, onReject, onCancel as OnCancel);
        });
    }

    get [Symbol.toStringTag]() {
        return "Cancellable Promise";
    }

    public then<TResult1 = T, TResult2 = never>(
        onFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
        onRejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null
    ): Promise<TResult1 | TResult2> {
        return this.#promise.then(onFulfilled, onRejected);
    }

    public catch<TResult = never>(
        onRejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null
    ): Promise<T | TResult> {
        return this.#promise.catch(onRejected);
    }

    public finally(onFinally?: (() => void) | null): Promise<T> {
        return this.#promise.finally(onFinally);
    }

    public cancel(): void {
        if (this.#isResolved || this.#isRejected || this.#isCancelled) {
            return;
        }
        this.#isCancelled = true;
        if (this.#cancelHandlers.length) {
            try {
                for (const cancelHandler of this.#cancelHandlers) {
                    cancelHandler();
                }
            } catch (error) {
                console.warn('Cancellation threw an error', error);
                return;
            }
        }
        this.#cancelHandlers.length = 0;
        if (this.#reject) this.#reject(new CancelError('Request aborted'));
    }

    public get isCancelled(): boolean {
        return this.#isCancelled;
    }
}

================
File: ClientApp/src/types/api/core/OpenAPI.ts
================
/* generated using openapi-typescript-codegen -- do not edit */
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { ApiRequestOptions } from "./ApiRequestOptions";

type Resolver<T> = (options: ApiRequestOptions) => Promise<T>;
type Headers = {
  [key: string]: string;
};

export type OpenAPIConfig = {
  BASE: string;
  VERSION: string;
  WITH_CREDENTIALS: boolean;
  CREDENTIALS: "include" | "omit" | "same-origin";
  TOKEN?: string | Resolver<string> | undefined;
  USERNAME?: string | Resolver<string> | undefined;
  PASSWORD?: string | Resolver<string> | undefined;
  HEADERS?: Headers | Resolver<Headers> | undefined;
  ENCODE_PATH?: ((path: string) => string) | undefined;
};

const API_BASE_URL = import.meta.env.VITE_API_URL || "http://localhost:3000";
const API_VERSION = "1.0.0";
const DEFAULT_CREDENTIALS = "include";
const CONTENT_TYPE_JSON = "application/json";

const getToken = async (): Promise<string> => {
  const token = localStorage.getItem("token");
  if (!token) {
    throw new Error("No token available");
  }
  return token;
};

const getCsrfToken = async (): Promise<string> => {
  try {
    const response = await fetch(`${API_BASE_URL}/auth/csrf-token`, {
      method: "GET",
      credentials: DEFAULT_CREDENTIALS,
    });
    if (!response.ok) throw new Error("Failed to get CSRF token");
    const data = await response.json();
    return data.csrfToken;
  } catch (error) {
    console.error("CSRF token error:", error);
    throw error;
  }
};

const getHeaders = async (): Promise<Headers> => {
  const headers: Headers = {
    "Content-Type": CONTENT_TYPE_JSON,
  };

  try {
    const [csrfToken, token] = await Promise.all([getCsrfToken(), getToken()]);

    headers["X-CSRF-Token"] = csrfToken;
    headers["Authorization"] = `Bearer ${token}`;
  } catch (error) {
    console.error("Headers error:", error);
  }

  return headers;
};

export const OpenAPI: OpenAPIConfig = {
  BASE: API_BASE_URL,
  VERSION: API_VERSION,
  WITH_CREDENTIALS: true,
  CREDENTIALS: "include",
  TOKEN: getToken,
  USERNAME: undefined,
  PASSWORD: undefined,
  HEADERS: getHeaders,
  ENCODE_PATH: undefined,
};

================
File: ClientApp/src/types/api/core/request.ts
================
/* generated using openapi-typescript-codegen -- do not edit */
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import axios from 'axios';
import type { AxiosError, AxiosRequestConfig, AxiosResponse, AxiosInstance } from 'axios';
import FormData from 'form-data';

import { ApiError } from './ApiError';
import type { ApiRequestOptions } from './ApiRequestOptions';
import type { ApiResult } from './ApiResult';
import { CancelablePromise } from './CancelablePromise';
import type { OnCancel } from './CancelablePromise';
import type { OpenAPIConfig } from './OpenAPI';

export const isDefined = <T>(value: T | null | undefined): value is Exclude<T, null | undefined> => {
    return value !== undefined && value !== null;
};

export const isString = (value: any): value is string => {
    return typeof value === 'string';
};

export const isStringWithValue = (value: any): value is string => {
    return isString(value) && value !== '';
};

export const isBlob = (value: any): value is Blob => {
    return (
        typeof value === 'object' &&
        typeof value.type === 'string' &&
        typeof value.stream === 'function' &&
        typeof value.arrayBuffer === 'function' &&
        typeof value.constructor === 'function' &&
        typeof value.constructor.name === 'string' &&
        /^(Blob|File)$/.test(value.constructor.name) &&
        /^(Blob|File)$/.test(value[Symbol.toStringTag])
    );
};

export const isFormData = (value: any): value is FormData => {
    return value instanceof FormData;
};

export const isSuccess = (status: number): boolean => {
    return status >= 200 && status < 300;
};

export const base64 = (str: string): string => {
    try {
        return btoa(str);
    } catch (err) {
        // @ts-ignore
        return Buffer.from(str).toString('base64');
    }
};

export const getQueryString = (params: Record<string, any>): string => {
    const qs: string[] = [];

    const append = (key: string, value: any) => {
        qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);
    };

    const process = (key: string, value: any) => {
        if (isDefined(value)) {
            if (Array.isArray(value)) {
                value.forEach(v => {
                    process(key, v);
                });
            } else if (typeof value === 'object') {
                Object.entries(value).forEach(([k, v]) => {
                    process(`${key}[${k}]`, v);
                });
            } else {
                append(key, value);
            }
        }
    };

    Object.entries(params).forEach(([key, value]) => {
        process(key, value);
    });

    if (qs.length > 0) {
        return `?${qs.join('&')}`;
    }

    return '';
};

const getUrl = (config: OpenAPIConfig, options: ApiRequestOptions): string => {
    const encoder = config.ENCODE_PATH || encodeURI;

    const path = options.url
        .replace('{api-version}', config.VERSION)
        .replace(/{(.*?)}/g, (substring: string, group: string) => {
            if (options.path?.hasOwnProperty(group)) {
                return encoder(String(options.path[group]));
            }
            return substring;
        });

    const url = `${config.BASE}${path}`;
    if (options.query) {
        return `${url}${getQueryString(options.query)}`;
    }
    return url;
};

export const getFormData = (options: ApiRequestOptions): FormData | undefined => {
    if (options.formData) {
        const formData = new FormData();

        const process = (key: string, value: any) => {
            if (isString(value) || isBlob(value)) {
                formData.append(key, value);
            } else {
                formData.append(key, JSON.stringify(value));
            }
        };

        Object.entries(options.formData)
            .filter(([_, value]) => isDefined(value))
            .forEach(([key, value]) => {
                if (Array.isArray(value)) {
                    value.forEach(v => process(key, v));
                } else {
                    process(key, value);
                }
            });

        return formData;
    }
    return undefined;
};

type Resolver<T> = (options: ApiRequestOptions) => Promise<T>;

export const resolve = async <T>(options: ApiRequestOptions, resolver?: T | Resolver<T>): Promise<T | undefined> => {
    if (typeof resolver === 'function') {
        return (resolver as Resolver<T>)(options);
    }
    return resolver;
};

export const getHeaders = async (config: OpenAPIConfig, options: ApiRequestOptions, formData?: FormData): Promise<Record<string, string>> => {
    const [token, username, password, additionalHeaders] = await Promise.all([
        resolve(options, config.TOKEN),
        resolve(options, config.USERNAME),
        resolve(options, config.PASSWORD),
        resolve(options, config.HEADERS),
    ]);

    const formHeaders = typeof formData?.getHeaders === 'function' && formData?.getHeaders() || {}

    const headers = Object.entries({
        Accept: 'application/json',
        ...additionalHeaders,
        ...options.headers,
        ...formHeaders,
    })
    .filter(([_, value]) => isDefined(value))
    .reduce((headers, [key, value]) => ({
        ...headers,
        [key]: String(value),
    }), {} as Record<string, string>);

    if (isStringWithValue(token)) {
        headers['Authorization'] = `Bearer ${token}`;
    }

    if (isStringWithValue(username) && isStringWithValue(password)) {
        const credentials = base64(`${username}:${password}`);
        headers['Authorization'] = `Basic ${credentials}`;
    }

    if (options.body !== undefined) {
        if (options.mediaType) {
            headers['Content-Type'] = options.mediaType;
        } else if (isBlob(options.body)) {
            headers['Content-Type'] = options.body.type || 'application/octet-stream';
        } else if (isString(options.body)) {
            headers['Content-Type'] = 'text/plain';
        } else if (!isFormData(options.body)) {
            headers['Content-Type'] = 'application/json';
        }
    }

    return headers;
};

export const getRequestBody = (options: ApiRequestOptions): any => {
    if (options.body) {
        return options.body;
    }
    return undefined;
};

export const sendRequest = async <T>(
    config: OpenAPIConfig,
    options: ApiRequestOptions,
    url: string,
    body: any,
    formData: FormData | undefined,
    headers: Record<string, string>,
    onCancel: OnCancel,
    axiosClient: AxiosInstance
): Promise<AxiosResponse<T>> => {
    const source = axios.CancelToken.source();

    const requestConfig: AxiosRequestConfig = {
        url,
        headers,
        data: body ?? formData,
        method: options.method,
        withCredentials: config.WITH_CREDENTIALS,
        withXSRFToken: config.CREDENTIALS === 'include' ? config.WITH_CREDENTIALS : false,
        cancelToken: source.token,
    };

    onCancel(() => source.cancel('The user aborted a request.'));

    try {
        return await axiosClient.request(requestConfig);
    } catch (error) {
        const axiosError = error as AxiosError<T>;
        if (axiosError.response) {
            return axiosError.response;
        }
        throw error;
    }
};

export const getResponseHeader = (response: AxiosResponse<any>, responseHeader?: string): string | undefined => {
    if (responseHeader) {
        const content = response.headers[responseHeader];
        if (isString(content)) {
            return content;
        }
    }
    return undefined;
};

export const getResponseBody = (response: AxiosResponse<any>): any => {
    if (response.status !== 204) {
        return response.data;
    }
    return undefined;
};

export const catchErrorCodes = (options: ApiRequestOptions, result: ApiResult): void => {
    const errors: Record<number, string> = {
        400: 'Bad Request',
        401: 'Unauthorized',
        403: 'Forbidden',
        404: 'Not Found',
        500: 'Internal Server Error',
        502: 'Bad Gateway',
        503: 'Service Unavailable',
        ...options.errors,
    }

    const error = errors[result.status];
    if (error) {
        throw new ApiError(options, result, error);
    }

    if (!result.ok) {
        const errorStatus = result.status ?? 'unknown';
        const errorStatusText = result.statusText ?? 'unknown';
        const errorBody = (() => {
            try {
                return JSON.stringify(result.body, null, 2);
            } catch (e) {
                return undefined;
            }
        })();

        throw new ApiError(options, result,
            `Generic Error: status: ${errorStatus}; status text: ${errorStatusText}; body: ${errorBody}`
        );
    }
};

/**
 * Request method
 * @param config The OpenAPI configuration object
 * @param options The request options from the service
 * @param axiosClient The axios client instance to use
 * @returns CancelablePromise<T>
 * @throws ApiError
 */
export const request = <T>(config: OpenAPIConfig, options: ApiRequestOptions, axiosClient: AxiosInstance = axios): CancelablePromise<T> => {
    return new CancelablePromise(async (resolve, reject, onCancel) => {
        try {
            const url = getUrl(config, options);
            const formData = getFormData(options);
            const body = getRequestBody(options);
            const headers = await getHeaders(config, options, formData);

            if (!onCancel.isCancelled) {
                const response = await sendRequest<T>(config, options, url, body, formData, headers, onCancel, axiosClient);
                const responseBody = getResponseBody(response);
                const responseHeader = getResponseHeader(response, options.responseHeader);

                const result: ApiResult = {
                    url,
                    ok: isSuccess(response.status),
                    status: response.status,
                    statusText: response.statusText,
                    body: responseHeader ?? responseBody,
                };

                catchErrorCodes(options, result);

                resolve(result.body);
            }
        } catch (error) {
            reject(error);
        }
    });
};

================
File: ClientApp/src/types/api/models/Error.ts
================
/* generated using openapi-typescript-codegen -- do not edit */
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export type Error = {
    error?: string;
    message?: string;
};

================
File: ClientApp/src/types/api/models/ForgotPasswordRequest.ts
================
/* generated using openapi-typescript-codegen -- do not edit */
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export type ForgotPasswordRequest = {
    email: string;
};

================
File: ClientApp/src/types/api/models/LoginRequest.ts
================
/* generated using openapi-typescript-codegen -- do not edit */
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export type LoginRequest = {
    username: string;
    password: string;
};

================
File: ClientApp/src/types/api/models/LoginResponse.ts
================
/* generated using openapi-typescript-codegen -- do not edit */
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { User } from './User';
export type LoginResponse = {
    token?: string;
    refreshToken?: string;
    user?: User;
};

================
File: ClientApp/src/types/api/models/RefreshTokenRequest.ts
================
/* generated using openapi-typescript-codegen -- do not edit */
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export type RefreshTokenRequest = {
    refreshToken: string;
};

================
File: ClientApp/src/types/api/models/RegisterRequest.ts
================
/* generated using openapi-typescript-codegen -- do not edit */
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export type RegisterRequest = {
    username: string;
    email: string;
    password: string;
    companyName?: string;
    branch?: string;
    division?: string;
    title?: string;
    telephoneNumber?: string;
};

================
File: ClientApp/src/types/api/models/ResetPasswordRequest.ts
================
/* generated using openapi-typescript-codegen -- do not edit */
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export type ResetPasswordRequest = {
    token: string;
    newPassword: string;
};

================
File: ClientApp/src/types/api/models/RFIDReadRequest.ts
================
/* generated using openapi-typescript-codegen -- do not edit */
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export type RFIDReadRequest = {
    tagId: string;
};

================
File: ClientApp/src/types/api/models/RFIDWriteRequest.ts
================
/* generated using openapi-typescript-codegen -- do not edit */
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export type RFIDWriteRequest = {
    tagId: string;
    data: string;
};

================
File: ClientApp/src/types/api/models/User.ts
================
/* generated using openapi-typescript-codegen -- do not edit */
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export type User = {
    id?: number;
    username?: string;
    email?: string;
    companyName?: string | null;
    branch?: string | null;
    division?: string | null;
    title?: string | null;
    telephoneNumber?: string | null;
};

================
File: ClientApp/src/types/api/services/AuthenticationService.ts
================
/* generated using openapi-typescript-codegen -- do not edit */
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { ForgotPasswordRequest } from '../models/ForgotPasswordRequest';
import type { LoginRequest } from '../models/LoginRequest';
import type { LoginResponse } from '../models/LoginResponse';
import type { RefreshTokenRequest } from '../models/RefreshTokenRequest';
import type { RegisterRequest } from '../models/RegisterRequest';
import type { ResetPasswordRequest } from '../models/ResetPasswordRequest';
import type { User } from '../models/User';
import type { CancelablePromise } from '../core/CancelablePromise';
import type { BaseHttpRequest } from '../core/BaseHttpRequest';
export class AuthenticationService {
    constructor(public readonly httpRequest: BaseHttpRequest) {}
    /**
     * Authenticate user and get tokens
     * @param requestBody
     * @returns LoginResponse Successful login
     * @throws ApiError
     */
    public postLogin(
        requestBody: LoginRequest,
    ): CancelablePromise<LoginResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/login',
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                401: `Invalid credentials`,
            },
        });
    }
    /**
     * Register a new user
     * @param requestBody
     * @returns User User registered successfully
     * @throws ApiError
     */
    public postRegister(
        requestBody: RegisterRequest,
    ): CancelablePromise<User> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/register',
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                409: `Username or email already exists`,
            },
        });
    }
    /**
     * Request password reset
     * @param requestBody
     * @returns any Password reset email sent
     * @throws ApiError
     */
    public postForgotPassword(
        requestBody: ForgotPasswordRequest,
    ): CancelablePromise<{
        message?: string;
    }> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/forgot-password',
            body: requestBody,
            mediaType: 'application/json',
        });
    }
    /**
     * Reset password using token
     * @param requestBody
     * @returns any Password reset successful
     * @throws ApiError
     */
    public postResetPassword(
        requestBody: ResetPasswordRequest,
    ): CancelablePromise<{
        message?: string;
    }> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/reset-password',
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                400: `Invalid or expired token`,
            },
        });
    }
    /**
     * Get new access token using refresh token
     * @param requestBody
     * @returns any New access token generated
     * @throws ApiError
     */
    public postRefreshToken(
        requestBody: RefreshTokenRequest,
    ): CancelablePromise<{
        token?: string;
    }> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/refresh-token',
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                401: `Invalid refresh token`,
            },
        });
    }
}

================
File: ClientApp/src/types/api/services/RfidService.ts
================
export class RfidService {
  constructor(public readonly httpRequest: BaseHttpRequest) {}

  public postRead(requestBody: RFIDReadRequest): CancelablePromise<{
    data?: string;
    user?: User;
  }> {
    return this.httpRequest.request({
      method: "POST",
      url: "/api/rfid/read",
      body: requestBody,
      mediaType: "application/json",
      errors: {
        500: `Error reading RFID tag`,
      },
    });
  }

  public postWrite(requestBody: RFIDWriteRequest): CancelablePromise<{
    message?: string;
    user?: User;
  }> {
    return this.httpRequest.request({
      method: "POST",
      url: "/api/rfid/write",
      body: requestBody,
      mediaType: "application/json",
      errors: {
        500: `Error writing to RFID tag`,
      },
    });
  }
}

================
File: ClientApp/src/types/api/index.ts
================
/* generated using openapi-typescript-codegen -- do not edit */
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
export { RFIDApi } from './RFIDApi';

export { ApiError } from './core/ApiError';
export { BaseHttpRequest } from './core/BaseHttpRequest';
export { CancelablePromise, CancelError } from './core/CancelablePromise';
export { OpenAPI } from './core/OpenAPI';
export type { OpenAPIConfig } from './core/OpenAPI';

export type { Error } from './models/Error';
export type { ForgotPasswordRequest } from './models/ForgotPasswordRequest';
export type { LoginRequest } from './models/LoginRequest';
export type { LoginResponse } from './models/LoginResponse';
export type { RefreshTokenRequest } from './models/RefreshTokenRequest';
export type { RegisterRequest } from './models/RegisterRequest';
export type { ResetPasswordRequest } from './models/ResetPasswordRequest';
export type { RFIDReadRequest } from './models/RFIDReadRequest';
export type { RFIDWriteRequest } from './models/RFIDWriteRequest';
export type { User } from './models/User';

export { AuthenticationService } from './services/AuthenticationService';
export { RfidService } from './services/RfidService';

================
File: ClientApp/src/types/api/RFIDApi.ts
================
/* generated using openapi-typescript-codegen -- do not edit */
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { BaseHttpRequest } from './core/BaseHttpRequest';
import type { OpenAPIConfig } from './core/OpenAPI';
import { AxiosHttpRequest } from './core/AxiosHttpRequest';
import { AuthenticationService } from './services/AuthenticationService';
import { RfidService } from './services/RfidService';
type HttpRequestConstructor = new (config: OpenAPIConfig) => BaseHttpRequest;
export class RFIDApi {
    public readonly authentication: AuthenticationService;
    public readonly rfid: RfidService;
    public readonly request: BaseHttpRequest;
    constructor(config?: Partial<OpenAPIConfig>, HttpRequest: HttpRequestConstructor = AxiosHttpRequest) {
        this.request = new HttpRequest({
            BASE: config?.BASE ?? 'http://localhost:3000',
            VERSION: config?.VERSION ?? '1.0.0',
            WITH_CREDENTIALS: config?.WITH_CREDENTIALS ?? false,
            CREDENTIALS: config?.CREDENTIALS ?? 'include',
            TOKEN: config?.TOKEN,
            USERNAME: config?.USERNAME,
            PASSWORD: config?.PASSWORD,
            HEADERS: config?.HEADERS,
            ENCODE_PATH: config?.ENCODE_PATH,
        });
        this.authentication = new AuthenticationService(this.request);
        this.rfid = new RfidService(this.request);
    }
}

================
File: ClientApp/src/types/react.d.ts
================
/// <reference types="react" />

declare module "react" {
  export = React;
  export as namespace React;
}

declare namespace React {
  interface JSX {
    IntrinsicElements: {
      [elemName: string]: any;
    };
  }

  type SetStateAction<S> = S | ((prevState: S) => S);
  type Dispatch<A> = (value: A) => void;

  function useState<S>(
    initialState: S | (() => S)
  ): [S, Dispatch<SetStateAction<S>>];
  function useState<S = undefined>(): [
    S | undefined,
    Dispatch<SetStateAction<S | undefined>>
  ];

  function useCallback<T extends (...args: any[]) => any>(
    callback: T,
    deps: ReadonlyArray<any>
  ): T;

  function useMemo<T>(
    factory: () => T,
    deps: ReadonlyArray<any> | undefined
  ): T;

  interface ChangeEvent<T = Element> {
    target: T;
    currentTarget: T;
  }

  interface InputHTMLAttributes<T> extends HTMLAttributes<T> {
    value?: string | number | readonly string[];
    onChange?: (event: ChangeEvent<HTMLInputElement>) => void;
  }

  interface HTMLAttributes<T> {
    className?: string;
    id?: string;
  }
}

================
File: ClientApp/src/utils/axios.ts
================
import axios from "axios";
import { message } from "antd";

const axiosInstance = axios.create({
  baseURL: import.meta.env.VITE_API_URL || "http://localhost:3000",
  withCredentials: true,
  headers: {
    "Content-Type": "application/json",
    Accept: "application/json",
  },
});

axiosInstance.interceptors.request.use(
  (config) => {
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

axiosInstance.interceptors.response.use(
  (response) => response,
  (error) => {
    if (!error.response) {
      console.error("Network error:", error);
      message.error(
        "サーバーに接続できません。ネットワーク接続を確認してください。"
      );
    }
    return Promise.reject(error);
  }
);

export default axiosInstance;

================
File: ClientApp/src/utils/serial.ts
================
export class SerialConnection {
  private port: SerialPort | null = null;
  private reader: ReadableStreamDefaultReader<string> | null = null;
  private writer: WritableStreamDefaultWriter<string> | null = null;
  private buffer: string = "";

  async connect(): Promise<boolean> {
    try {
      this.port = await navigator.serial.requestPort();
      await this.port.open({
        baudRate: 9600,
        dataBits: 7,
        stopBits: 2,
        parity: "even",
        flowControl: "none",
      });
      const textDecoder = new TextDecoderStream();
      this.port.readable!.pipeTo(textDecoder.writable);
      this.reader = textDecoder.readable.getReader();
      const textEncoder = new TextEncoderStream();
      textEncoder.readable.pipeTo(this.port.writable!);
      this.writer = textEncoder.writable.getWriter();
      console.log("Successfully connected to V680-CH1D");
      this.startReading();
      return true;
    } catch (error) {
      console.error("Error connecting to V680-CH1D:", error);
      return false;
    }
  }

  private async startReading() {
    while (true) {
      try {
        const { value, done } = await this.reader!.read();
        if (done) {
          console.log("Reader has been canceled");
          break;
        }
        if (value) {
          this.buffer += value;
        }
      } catch (error) {
        console.error("Error reading from serial:", error);
        break;
      }
    }
  }

  async sendCommand(command: string): Promise<string> {
    if (!this.writer) {
      throw new Error("Not connected to a serial port");
    }
    console.log("Sending command:", command);
    this.buffer = ""; // Clear the buffer before sending a new command
    await this.writer.write(command + "\r");

    // Wait for the response
    const response = await this.waitForResponse();
    console.log("Full response:", response);
    return response;
  }

  private async waitForResponse(): Promise<string> {
    const maxWaitTime = 5000; // 5 seconds
    const startTime = Date.now();

    while (Date.now() - startTime < maxWaitTime) {
      if (this.buffer.includes("*")) {
        const response = this.buffer;
        this.buffer = "";
        return response;
      }
      await new Promise((resolve) => setTimeout(resolve, 100)); // Wait 100ms before checking again
    }

    throw new Error("Timeout waiting for response");
  }

  async disconnect(): Promise<void> {
    if (this.reader) {
      await this.reader.cancel();
      this.reader = null;
    }
    if (this.writer) {
      await this.writer.close();
      this.writer = null;
    }
    if (this.port) {
      await this.port.close();
      this.port = null;
    }
    console.log("Disconnected from V680-CH1D");
  }
}

================
File: ClientApp/src/App.tsx
================
import React from "react";
import {
  BrowserRouter as Router,
  Routes,
  Route,
  Navigate,
} from "react-router-dom";
import { Layout, Button, Space } from "antd";
import { AuthProvider, useAuth } from "./contexts/AuthContext";
import Login from "./components/Login";
import Register from "./components/Register";
import { RFIDHandler } from "./components/RFIDHandler";
import "./index.css";
import "./styles/auth.css";

const { Header, Content } = Layout;

type ProtectedRouteProps = {
  children: React.ReactNode;
};

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children }) => {
  const { isAuthenticated } = useAuth();
  return isAuthenticated ? <>{children}</> : <Navigate to="/login" />;
};

const PublicRoute = ({ children }: { children: React.ReactNode }) => {
  const { isAuthenticated } = useAuth();
  return !isAuthenticated ? children : <Navigate to="/" />;
};

const AppRoutes: React.FC = () => {
  const { isAuthenticated, logout, user } = useAuth();

  return (
    <Layout className="app-container">
      {isAuthenticated && (
        <Header className="app-header">
          <div
            style={{
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              width: "100%",
            }}
          >
            <h2 style={{ color: "white", margin: 0 }}>
              RFID タグリーダー/ライター
            </h2>
            <Space>
              <span className="username">{user?.username}</span>
              <Button
                type="link"
                onClick={logout}
                style={{ color: "white", padding: "4px 0" }}
              >
                ログアウト
              </Button>
            </Space>
          </div>
        </Header>
      )}
      <Content className="app-content">
        <Routes>
          <Route
            path="/login"
            element={
              <PublicRoute>
                <Login />
              </PublicRoute>
            }
          />
          <Route
            path="/register"
            element={
              <PublicRoute>
                <Register />
              </PublicRoute>
            }
          />
          <Route
            path="/"
            element={
              <ProtectedRoute>
                <RFIDHandler />
              </ProtectedRoute>
            }
          />
        </Routes>
      </Content>
    </Layout>
  );
};

const App: React.FC = () => {
  return (
    <Router>
      <AuthProvider>
        <AppRoutes />
      </AuthProvider>
    </Router>
  );
};

export default App;

================
File: ClientApp/src/index.css
================
@import "antd/dist/reset.css";

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen",
    "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue",
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  font-size: 18px;
}

.app-container {
  min-height: 100vh;
}

.app-header {
  background: #1890ff;
  padding: 0 20px;
  display: flex;
  align-items: center;
}

.app-header .ant-space {
  margin-left: auto;
}

.app-header .username {
  color: white;
  font-size: 16px;
  margin-right: 16px;
}

.app-content {
  padding: 24px;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: calc(100vh - 64px);
}

.main-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
  max-width: 500px;
}

.connect-button {
  width: 100%;
  margin-bottom: 20px;
  font-size: 24px;
  height: auto;
}

.action-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
  margin-bottom: 20px;
}

.action-button {
  width: 100%;
  margin-bottom: 10px;
  font-size: 24px;
  height: auto;
}

.read-result {
  font-size: 36px;
  margin-top: 20px;
  text-align: center;
}

.read-result .ant-typography {
  font-size: 36px;
}

.write-input {
  width: 100%;
  margin-bottom: 10px;
  font-size: 24px;
  height: auto;
}

.ant-input::placeholder {
  font-size: 18px;
}

@media (max-width: 768px) {
  body {
    font-size: 16px;
  }

  .app-header {
    padding: 0 10px;
  }

  .app-content {
    padding: 12px;
  }
}

================
File: ClientApp/src/main.tsx
================
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App.tsx";
import "./index.css";

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

================
File: ClientApp/src/RFIDHandler.tsx
================
import React, { useState, useEffect } from "react";
import { V680RFIDHandler } from "./rfid/V680RFIDHandler";

const RFIDHandler: React.FC = () => {
  const [rfidHandler] = useState(() => new V680RFIDHandler());
  const [connected, setConnected] = useState(false);
  const [readData, setReadData] = useState("");
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const connectRFID = async () => {
      try {
        const isConnected = await rfidHandler.connect();
        setConnected(isConnected);
        if (isConnected) {
          console.log("Connected to RFID reader");
        } else {
          console.log("Failed to connect to RFID reader");
        }
      } catch (err) {
        console.error("Error connecting to RFID reader:", err);
        setError("Failed to connect to RFID reader");
      }
    };

    connectRFID();

    return () => {
      rfidHandler.disconnect();
    };
  }, [rfidHandler]);

  const handleRead = async () => {
    try {
      const data = await rfidHandler.readData();
      setReadData(data);
      console.log("Read data:", data);
    } catch (err) {
      console.error("Error reading data:", err);
      setError("Failed to read data from RFID");
    }
  };

  const handleWrite = async () => {
    try {
      await rfidHandler.writeData("Hello RFID");
      console.log("Data written successfully");
    } catch (err) {
      console.error("Error writing data:", err);
      setError("Failed to write data to RFID");
    }
  };

  if (error) {
    return <div>Error: {error}</div>;
  }

  return (
    <div>
      <h1>RFID Handler</h1>
      <p>Connection status: {connected ? "Connected" : "Disconnected"}</p>
      <button onClick={handleRead}>Read RFID</button>
      <button onClick={handleWrite}>Write to RFID</button>
      {readData && <p>Read data: {readData}</p>}
    </div>
  );
};

export default RFIDHandler;

================
File: ClientApp/src/vite-env.d.ts
================
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_API_URL: string;
  readonly PROD: boolean;
  readonly DEV: boolean;
  readonly MODE: string;
  readonly BASE_URL: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}

================
File: ClientApp/.env.development
================
VITE_API_URL=http://localhost:3000

================
File: ClientApp/.env.production
================
VITE_API_URL=https://rfidwrite-6a6b8d6813db.herokuapp.com

================
File: ClientApp/.eslintrc.cjs
================
module.exports = {
  root: true,
  env: { browser: true, es2020: true },
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:react-hooks/recommended',
  ],
  ignorePatterns: ['dist', '.eslintrc.cjs'],
  parser: '@typescript-eslint/parser',
  plugins: ['react-refresh'],
  rules: {
    'react-refresh/only-export-components': [
      'warn',
      { allowConstantExport: true },
    ],
  },
}

================
File: ClientApp/.node-version
================
20.13.1

================
File: ClientApp/index.html
================
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>RFID Web Writer</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

================
File: ClientApp/package.json
================
{
  "name": "rfid-writer-client",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint src --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "dependencies": {
    "@ant-design/icons": "^5.5.1",
    "antd": "^5.15.3",
    "axios": "^1.7.7",
    "form-data": "^4.0.1",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.27.0",
    "vite": "^5.1.6",
    "@vitejs/plugin-react-swc": "^3.6.0",
    "typescript": "^5.4.2"
  },
  "devDependencies": {
    "@types/react": "^18.2.66",
    "@types/react-dom": "^18.2.22",
    "@typescript-eslint/eslint-plugin": "^7.2.0",
    "@typescript-eslint/parser": "^7.2.0"
  }
}

================
File: ClientApp/tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "allowJs": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Type Checking */
    "strict": false,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noFallthroughCasesInSwitch": true,
    "noImplicitAny": false,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}

================
File: ClientApp/tsconfig.node.json
================
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true,
    "strict": true
  },
  "include": ["vite.config.ts"]
}

================
File: ClientApp/vite.config.ts
================
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react-swc";

export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
    host: true,
    strictPort: true,
    proxy: {
      "/api": {
        target: "http://localhost:3000",
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, ""),
      },
    },
  },
});

================
File: prisma/migrations/20241011090817_update_user_schema/migration.sql
================
-- CreateTable
CREATE TABLE "User" (
    "id" SERIAL NOT NULL,
    "username" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "password" TEXT NOT NULL,
    "resetToken" TEXT,
    "resetTokenExpiry" TIMESTAMP(3),
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "companyName" TEXT,
    "branch" TEXT,
    "division" TEXT,
    "title" TEXT,
    "telephoneNumber" TEXT,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "User_username_key" ON "User"("username");

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

================
File: prisma/migrations/20241029060101_add_role_field/migration.sql
================
-- AlterTable
ALTER TABLE "User" ADD COLUMN     "role" TEXT NOT NULL DEFAULT 'USER';

================
File: prisma/migrations/migration_lock.toml
================
# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"

================
File: prisma/schema.prisma
================
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id               Int       @id @default(autoincrement())
  username         String    @unique
  email            String    @unique
  password         String
  role             String    @default("USER")
  resetToken       String?
  resetTokenExpiry DateTime?
  createdAt        DateTime  @default(now())
  companyName      String?
  branch           String?
  division         String?
  title            String?
  telephoneNumber  String?
}

================
File: server/lib/prisma.ts
================
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

export default prisma;

================
File: server/rfid/V680RFIDHandler.ts
================
import { SerialPort } from "serialport";

export class V680RFIDHandler {
  private port: SerialPort | null = null;
  private possiblePorts = [
    "/dev/ttyUSB0",
    "/dev/ttyUSB1",
    "/dev/tty.usbserial",
    "/dev/tty.usbmodem",
    "/dev/ttyACM0",
  ];

  async connect(): Promise<boolean> {
    const ports = await SerialPort.list();
    console.log("Available ports:", ports);

    for (const portPath of this.possiblePorts) {
      try {
        this.port = new SerialPort({
          path: portPath,
          baudRate: 9600,
          dataBits: 7,
          stopBits: 2,
          parity: "even",
        });

        await new Promise<void>((resolve, reject) => {
          this.port!.on("open", () => {
            console.log(`Connected to ${portPath}`);
            resolve();
          });
          this.port!.on("error", (err) => {
            console.log(`Failed to connect to ${portPath}:`, err);
            reject(err);
          });
        });

        return true;
      } catch (error) {
        console.log(`Failed to connect to ${portPath}:`, error);
        continue;
      }
    }

    console.error("Failed to connect to any serial port");
    return false;
  }

  async disconnect(): Promise<void> {
    if (this.port) {
      await new Promise<void>((resolve) => this.port!.close(() => resolve()));
      this.port = null;
    }
  }

  async readData(): Promise<string> {
    if (!this.port) throw new Error("Not connected to a serial port");
    const command = "RDH1000010*\r";
    const response = await this.sendCommand(command);
    const hexData = this.cleanRawData(response);
    return this.hexToDecimal(hexData);
  }

  async writeData(data: string): Promise<void> {
    if (!this.port) throw new Error("Not connected to a serial port");
    const hexData = this.decimalToHex(data);
    const command = `WTH1000010${hexData}*\r`;
    const response = await this.sendCommand(command);
    if (!response.startsWith("WT00")) {
      throw new Error(`Unexpected write response: ${response}`);
    }
  }

  private async sendCommand(command: string): Promise<string> {
    return new Promise((resolve, reject) => {
      let response = "";

      const dataHandler = (data: Buffer) => {
        response += data.toString();
        if (response.includes("*")) {
          cleanup();
          resolve(response);
        }
      };

      const errorHandler = (error: Error) => {
        cleanup();
        reject(error);
      };

      const cleanup = () => {
        this.port!.removeListener("data", dataHandler);
        this.port!.removeListener("error", errorHandler);
      };

      this.port!.on("data", dataHandler);
      this.port!.on("error", errorHandler);

      this.port!.write(command, (err) => {
        if (err) {
          cleanup();
          reject(err);
        }
      });

      setTimeout(() => {
        cleanup();
        reject(new Error("Command timeout"));
      }, 5000);
    });
  }

  private cleanRawData(data: string): string {
    return data.replace(/^RD00/, "").replace(/\*$/, "");
  }

  private hexToDecimal(hex: string): string {
    const truncatedHex = hex.slice(0, 8);
    return parseInt(truncatedHex, 16).toString();
  }

  private decimalToHex(decimal: string): string {
    const number = parseInt(decimal, 10);
    if (isNaN(number) || number < 0 || number > 4294967295) {
      throw new Error(
        "Invalid decimal number. Please enter a number between 0 and 4294967295."
      );
    }
    return number.toString(16).padStart(8, "0").toUpperCase();
  }
}

================
File: server/routes/auth.ts
================
import { FastifyPluginAsync, FastifyRequest, FastifyReply } from "fastify";
import prisma from "../lib/prisma.js";
import bcrypt from "bcrypt";
import { EmailService } from "../services/EmailService.js";
import crypto from "crypto";

interface LoginBody {
  username: string;
  password: string;
}

interface RegisterBody {
  username: string;
  email: string;
  password: string;
  companyName?: string;
  branch?: string;
  division?: string;
  title?: string;
  telephoneNumber?: string;
}

interface ResetPasswordBody {
  token: string;
  newPassword: string;
}

interface PrismaError {
  code?: string;
  message?: string;
}

const emailService = new EmailService();

const authRoutes: FastifyPluginAsync = async (fastify) => {
  fastify.get("/check", async (request, reply) => {
    try {
      const token = request.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        return reply.code(401).send({ error: "No token provided" });
      }

      const decoded = fastify.jwt.verify(token);
      return { authenticated: true, user: decoded };
    } catch (error) {
      return reply.code(401).send({ error: "Invalid token" });
    }
  });

  fastify.get("/csrf-token", async (request, reply) => {
    const csrfToken = crypto.randomBytes(32).toString("hex");
    return { csrfToken };
  });

  fastify.post("/logout", async (request, reply) => {
    return reply.send({ message: "Logged out successfully" });
  });

  fastify.post<{ Body: LoginBody }>(
    "/login",
    {
      schema: {
        body: {
          type: "object",
          required: ["username", "password"],
          properties: {
            username: { type: "string" },
            password: { type: "string" },
          },
        },
      },
    },
    async (request, reply) => {
      const { username, password } = request.body;

      const user = await prisma.user.findUnique({
        where: { username },
      });

      if (!user || !(await bcrypt.compare(password, user.password))) {
        return reply.code(401).send({ error: "Invalid username or password" });
      }

      const token = fastify.jwt.sign(
        {
          id: user.id,
          username: user.username,
          email: user.email,
          companyName: user.companyName,
          branch: user.branch,
          division: user.division,
          title: user.title,
          telephoneNumber: user.telephoneNumber,
        },
        { expiresIn: "15m" }
      );

      const refreshToken = fastify.jwt.sign(
        {
          id: user.id,
          username: user.username,
          email: user.email,
        },
        { expiresIn: "7d" }
      );

      return { token, refreshToken, user };
    }
  );

  fastify.post<{ Body: RegisterBody }>(
    "/register",
    {
      schema: {
        body: {
          type: "object",
          required: ["username", "email", "password"],
          properties: {
            username: { type: "string" },
            email: { type: "string", format: "email" },
            password: { type: "string", minLength: 6 },
            companyName: { type: "string" },
            branch: { type: "string" },
            division: { type: "string" },
            title: { type: "string" },
            telephoneNumber: { type: "string" },
          },
        },
      },
    },
    async (request, reply) => {
      const {
        username,
        email,
        password,
        companyName,
        branch,
        division,
        title,
        telephoneNumber,
      } = request.body;

      try {
        if (!username || !email || !password) {
          return reply.code(400).send({
            error: "Missing required fields",
            details: "Username, email and password are required",
          });
        }

        if (password.length < 6) {
          return reply.code(400).send({
            error: "Invalid password",
            details: "Password must be at least 6 characters long",
          });
        }

        const existingUser = await prisma.user.findFirst({
          where: {
            OR: [{ username }, { email }],
          },
        });

        if (existingUser) {
          return reply.code(409).send({
            error: "User already exists",
            details: "Username or email is already registered",
          });
        }

        const hashedPassword = await bcrypt.hash(password, 10);
        const user = await prisma.user.create({
          data: {
            username,
            email,
            password: hashedPassword,
            companyName,
            branch,
            division,
            title,
            telephoneNumber,
          },
        });

        try {
          await emailService.sendRegistrationEmail(email, username);
        } catch (error) {
          console.error("Failed to send registration email:", error);
        }

        const { password: _, ...userResponse } = user;
        return reply.code(201).send(userResponse);
      } catch (error) {
        console.error("Registration error:", error);
        const prismaError = error as PrismaError;

        if (prismaError.code === "P2002") {
          return reply.code(409).send({
            error: "Conflict",
            details: "Username or email is already registered",
          });
        }

        return reply.code(500).send({
          error: "Internal server error",
          details: "An error occurred during registration",
        });
      }
    }
  );

  fastify.post<{ Body: { email: string } }>(
    "/forgot-password",
    {
      schema: {
        body: {
          type: "object",
          required: ["email"],
          properties: {
            email: { type: "string", format: "email" },
          },
        },
      },
    },
    async (request, reply) => {
      const { email } = request.body;

      const user = await prisma.user.findUnique({
        where: { email },
      });

      if (user) {
        const resetToken = crypto.randomBytes(20).toString("hex");
        const resetTokenExpiry = new Date(Date.now() + 3600000);

        await prisma.user.update({
          where: { email },
          data: { resetToken, resetTokenExpiry },
        });

        try {
          await emailService.sendPasswordResetEmail(email, resetToken);
          return reply.send({
            message:
              "If an account exists with that email, a password reset link has been sent.",
          });
        } catch (error) {
          console.error("Failed to send password reset email:", error);
          return reply.code(500).send({
            error: "Failed to send password reset email",
          });
        }
      }

      return reply.send({
        message:
          "If an account with that email exists, a password reset link has been sent.",
      });
    }
  );

  fastify.post<{ Body: ResetPasswordBody }>(
    "/reset-password",
    {
      schema: {
        body: {
          type: "object",
          required: ["token", "newPassword"],
          properties: {
            token: { type: "string" },
            newPassword: { type: "string", minLength: 6 },
          },
        },
      },
    },
    async (request, reply) => {
      const { token, newPassword } = request.body;

      const user = await prisma.user.findFirst({
        where: {
          resetToken: token,
          resetTokenExpiry: { gt: new Date() },
        },
      });

      if (!user) {
        return reply
          .code(400)
          .send({ error: "Invalid or expired reset token" });
      }

      const hashedPassword = await bcrypt.hash(newPassword, 10);

      await prisma.user.update({
        where: { id: user.id },
        data: {
          password: hashedPassword,
          resetToken: null,
          resetTokenExpiry: null,
        },
      });

      return reply.send({ message: "Password has been reset successfully" });
    }
  );

  fastify.post<{ Body: { refreshToken: string } }>(
    "/refresh-token",
    {
      schema: {
        body: {
          type: "object",
          required: ["refreshToken"],
          properties: {
            refreshToken: { type: "string" },
          },
        },
      },
    },
    async (request, reply) => {
      if (!request.body || !request.body.refreshToken) {
        return reply.code(400).send({ error: "Refresh token is required" });
      }

      const { refreshToken } = request.body;

      try {
        const decoded = fastify.jwt.verify<{
          id: number;
          username: string;
          email: string;
          iat?: number;
          exp?: number;
        }>(refreshToken);

        const user = await prisma.user.findUnique({
          where: { id: decoded.id },
        });

        if (!user) {
          return reply.code(401).send({ error: "Invalid refresh token" });
        }

        const token = fastify.jwt.sign(
          {
            id: user.id,
            username: user.username,
            email: user.email,
            companyName: user.companyName,
            branch: user.branch,
            division: user.division,
            title: user.title,
            telephoneNumber: user.telephoneNumber,
          },
          { expiresIn: "15m" }
        );

        return { token };
      } catch (error) {
        return reply.code(401).send({ error: "Invalid refresh token" });
      }
    }
  );
};

export default authRoutes;

================
File: server/routes/index.ts
================
export { default as rfidRoutes } from "./rfid.js";
export { default as authRoutes } from "./auth.js";

================
File: server/routes/rfid.ts
================
import { FastifyPluginAsync, FastifyRequest } from "fastify";
import { V680RFIDHandler } from "../rfid/V680RFIDHandler.js";

const rfidHandler = new V680RFIDHandler();

interface User {
  id: number;
  username: string;
  email: string;
  companyName?: string | null;
  branch?: string | null;
  division?: string | null;
  title?: string | null;
  telephoneNumber?: string | null;
}

interface ReadBody {
  tagId: string;
}

interface WriteBody {
  tagId: string;
  data: string;
}

const rfidRoutes: FastifyPluginAsync = async (fastify) => {
  fastify.addHook("onRequest", async (request, reply) => {
    try {
      await request.jwtVerify();
    } catch (err) {
      reply.code(401).send(err);
      throw err;
    }
  });

  fastify.post<{ Body: ReadBody }>(
    "/read",
    {
      schema: {
        body: {
          type: "object",
          required: ["tagId"],
          properties: {
            tagId: { type: "string" },
          },
        },
        response: {
          200: {
            type: "object",
            properties: {
              data: { type: "string" },
              user: {
                type: "object",
                properties: {
                  username: { type: "string" },
                  companyName: { type: ["string", "null"] },
                  branch: { type: ["string", "null"] },
                  division: { type: ["string", "null"] },
                  title: { type: ["string", "null"] },
                },
              },
            },
          },
          500: {
            type: "object",
            properties: {
              message: { type: "string" },
            },
          },
        },
      },
    },
    async (request: FastifyRequest<{ Body: ReadBody }>, reply) => {
      const user = request.user as User;
      const { tagId } = request.body;

      try {
        return {
          data: tagId,
          user: {
            username: user.username,
            companyName: user.companyName,
            branch: user.branch,
            division: user.division,
            title: user.title,
          },
        };
      } catch (error) {
        fastify.log.error(error);
        return reply.code(500).send({ message: "Error reading RFID tag" });
      }
    }
  );

  fastify.post<{ Body: WriteBody }>(
    "/write",
    {
      schema: {
        body: {
          type: "object",
          required: ["tagId", "data"],
          properties: {
            tagId: { type: "string" },
            data: { type: "string" },
          },
        },
        response: {
          200: {
            type: "object",
            properties: {
              message: { type: "string" },
              user: {
                type: "object",
                properties: {
                  username: { type: "string" },
                  companyName: { type: ["string", "null"] },
                  branch: { type: ["string", "null"] },
                  division: { type: ["string", "null"] },
                  title: { type: ["string", "null"] },
                },
              },
            },
          },
          500: {
            type: "object",
            properties: {
              message: { type: "string" },
            },
          },
        },
      },
    },
    async (request: FastifyRequest<{ Body: WriteBody }>, reply) => {
      const user = request.user as User;
      const { tagId, data } = request.body;

      try {
        await rfidHandler.connect();
        await rfidHandler.writeData(data);
        await rfidHandler.disconnect();

        const message = `Data written to tag ${tagId} successfully`;
        return {
          message,
          user: {
            username: user.username,
            companyName: user.companyName,
            branch: user.branch,
            division: user.division,
            title: user.title,
          },
        };
      } catch (error) {
        fastify.log.error(error);
        return reply.code(500).send({ message: "Error writing to RFID tag" });
      }
    }
  );
};

export default rfidRoutes;

================
File: server/services/EmailService.ts
================
import nodemailer from "nodemailer";
import SMTPTransport from "nodemailer/lib/smtp-transport";
import { ConnectionOptions } from "tls";

interface EmailConfig extends SMTPTransport.Options {
  host: string;
  port: number;
  secure: boolean;
  auth: {
    user: string;
    pass: string;
  };
  tls?: ConnectionOptions;
}

interface EmailOptions {
  from: {
    name: string;
    address: string;
  };
  to: string;
  subject: string;
  text: string;
  html: string;
}

export class EmailService {
  private transporter: nodemailer.Transporter<SMTPTransport.SentMessageInfo>;
  private readonly companyName = "株式会社エムケイシステム";
  private readonly defaultConfig: SMTPTransport.Options = {
    host: process.env.SMTP_HOST,
    port: parseInt(process.env.SMTP_PORT || "587", 10),
    secure: process.env.SMTP_SECURE === "true",
    auth: {
      user: process.env.SMTP_USER,
      pass: process.env.SMTP_PASS,
    },
    tls: {
      rejectUnauthorized: false,
      minVersion: "TLSv1.2" as const,
    },
  };

  constructor(config?: Partial<SMTPTransport.Options>) {
    console.log("Email Configuration:", {
      host: this.defaultConfig.host,
      port: this.defaultConfig.port,
      secure: this.defaultConfig.secure,
      user: this.defaultConfig.auth?.user,
      hasPass: !!this.defaultConfig.auth?.pass,
      emailFrom: process.env.EMAIL_FROM,
    });

    const finalConfig = { ...this.defaultConfig, ...config };
    this.transporter = nodemailer.createTransport(finalConfig);

    if (process.env.NODE_ENV === "production") {
      this.verifyConnection();
    }
  }

  private async verifyConnection(): Promise<void> {
    try {
      await this.transporter.verify();
      console.log("SMTP connection verified successfully");
    } catch (error) {
      console.error("SMTP connection verification failed:", error);
      throw new Error("Failed to establish SMTP connection");
    }
  }

  private getFromAddress(): string {
    return process.env.EMAIL_FROM || process.env.SMTP_USER || "";
  }

  public async sendRegistrationEmail(
    email: string,
    username: string
  ): Promise<void> {
    const mailOptions: EmailOptions = {
      from: {
        name: this.companyName,
        address: this.getFromAddress(),
      },
      to: email,
      subject:
        "株式会社エムケイシステム RFID書き込みサービスへの登録完了のお知らせ",
      text: this.getRegistrationEmailText(username),
      html: this.getRegistrationEmailHtml(username),
    };

    try {
      await this.transporter.sendMail(mailOptions);
      console.log("Registration email sent successfully to:", email);
    } catch (error) {
      console.error("Failed to send registration email:", error);
      throw new Error("登録完了メールの送信に失敗しました");
    }
  }

  public async sendPasswordResetEmail(
    email: string,
    resetToken: string
  ): Promise<void> {
    const resetUrl = `${process.env.FRONTEND_URL}/reset-password?token=${resetToken}`;
    const mailOptions: EmailOptions = {
      from: {
        name: this.companyName,
        address: this.getFromAddress(),
      },
      to: email,
      subject: "パスワードリセットのご案内",
      text: this.getPasswordResetEmailText(resetUrl),
      html: this.getPasswordResetEmailHtml(resetUrl),
    };

    try {
      await this.transporter.sendMail(mailOptions);
      console.log("Password reset email sent successfully to:", email);
    } catch (error) {
      console.error("Failed to send password reset email:", error);
      throw new Error("パスワードリセットメールの送信に失敗しました");
    }
  }

  private getRegistrationEmailText(username: string): string {
    return `${username} 様

この度は、株式会社エムケイシステムRFID書き込みサービスへの登録ありがとうございます。
登録が正常に完了いたしましたので、ご連絡申し上げます。

ユーザー名とパスワードを使用してログインすることができます。

ご不明な点がございましたら、お気軽にお問い合わせください。`;
  }

  private getRegistrationEmailHtml(username: string): string {
    return `
      <p>${username} 様</p>
      <p>この度は、株式会社エムケイシステムRFID書き込みサービスへの登録ありがとうございます。</p>
      <p>登録が正常に完了いたしましたので、ご連絡申し上げます。</p>
      <p>ユーザー名とパスワードを使用してログインすることができます。</p>
      <p>ご不明な点がございましたら、お気軽にお問い合わせください。</p>
    `;
  }

  private getPasswordResetEmailText(resetUrl: string): string {
    return `パスワードリセットのリクエストを受け付けました。
以下のリンクをクリックしてパスワードをリセットしてください：

${resetUrl}

このリクエストに心当たりがない場合は、このメールを無視してください。`;
  }

  private getPasswordResetEmailHtml(resetUrl: string): string {
    return `
      <p>パスワードリセットのリクエストを受け付けました。</p>
      <p>以下のリンクをクリックしてパスワードをリセットしてください：</p>
      <a href="${resetUrl}">${resetUrl}</a>
      <p>このリクエストに心当たりがない場合は、このメールを無視してください。</p>
    `;
  }
}

================
File: server/server.ts
================
import "dotenv/config";
import fastify, {
  FastifyInstance,
  FastifyRequest,
  FastifyReply,
} from "fastify";
import fastifySwagger from "@fastify/swagger";
import fastifySwaggerUi from "@fastify/swagger-ui";
import fastifyCors from "@fastify/cors";
import fastifyJwt from "@fastify/jwt";
import fastifyFormBody from "@fastify/formbody";
import fastifyRateLimit from "@fastify/rate-limit";
import fastifyStatic from "@fastify/static";
import path from "path";
import { fileURLToPath } from "url";
import { rfidRoutes, authRoutes } from "./routes/index.js";
import { pino } from "pino";
import bcrypt from "bcrypt";
import fs from "fs";

console.log("Environment Check:", {
  NODE_ENV: process.env.NODE_ENV,
  SMTP_HOST: process.env.SMTP_HOST,
  DATABASE_URL: process.env.DATABASE_URL?.substring(0, 20) + "...",
  PORT: process.env.PORT,
});

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const clientAppPath = path.join(process.cwd(), "ClientApp", "dist");
if (!fs.existsSync(clientAppPath)) {
  fs.mkdirSync(clientAppPath, { recursive: true });
  console.log(`Created directory: ${clientAppPath}`);
}

type BcryptDecorator = {
  hash: typeof bcrypt.hash;
  compare: typeof bcrypt.compare;
};

export async function build(): Promise<FastifyInstance> {
  const app = fastify({
    logger: {
      level: process.env.LOG_LEVEL || "info",
      transport: {
        target: "pino-pretty",
        options: {
          colorize: true,
        },
      },
    },
  });

  app.decorate<BcryptDecorator>("bcrypt", {
    hash: bcrypt.hash,
    compare: bcrypt.compare,
  });

  await app.register(fastifyCors, {
    origin: [
      "http://localhost:5173",
      "http://localhost:3000",
      "https://rfidwrite-6a6b8d6813db.herokuapp.com",
      /\.herokuapp\.com$/,
    ],
    credentials: true,
    methods: ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
    allowedHeaders: [
      "Origin",
      "X-Requested-With",
      "Content-Type",
      "Accept",
      "Authorization",
      "X-CSRF-Token",
    ],
    exposedHeaders: ["set-cookie"],
  });

  await app.register(fastifyJwt, {
    secret: process.env.JWT_SECRET!,
    sign: {
      expiresIn: "15m",
    },
  });

  app.decorate(
    "authenticate",
    async function (request: FastifyRequest, reply: FastifyReply) {
      try {
        await request.jwtVerify();
      } catch (err) {
        reply.code(401).send(err);
        throw err;
      }
    }
  );

  await app.register(fastifyFormBody);
  await app.register(fastifyRateLimit, {
    max: 100,
    timeWindow: "1 minute",
  });

  await app.register(fastifySwagger, {
    swagger: {
      info: {
        title: "RFID Management API",
        description: "API for managing RFID tags",
        version: "1.0.0",
      },
      host:
        process.env.NODE_ENV === "production"
          ? "rfidwrite-6a6b8d6813db.herokuapp.com"
          : "localhost:3000",
      schemes: ["https", "http"],
      consumes: ["application/json"],
      produces: ["application/json"],
    },
  });

  await app.register(fastifySwaggerUi, {
    routePrefix: "/documentation",
  });

  await app.register(authRoutes, { prefix: "/auth" });
  await app.register(rfidRoutes, { prefix: "/api/rfid" });

  app.get("/health", async () => {
    return { status: "ok" };
  });

  await app.register(fastifyStatic, {
    root: path.join(process.cwd(), "ClientApp", "dist"),
    prefix: "/",
    decorateReply: true,
  });

  app.setNotFoundHandler(
    async (request: FastifyRequest, reply: FastifyReply) => {
      if (request.url.startsWith("/api") || request.url.startsWith("/auth")) {
        reply.status(404).send({ error: "API route not found" });
      } else {
        await reply.sendFile("index.html");
      }
    }
  );

  app.setErrorHandler(
    (error: Error, request: FastifyRequest, reply: FastifyReply) => {
      app.log.error(error);
      reply.status(500).send({ error: "An internal server error occurred" });
    }
  );

  return app;
}

const startServer = async () => {
  if (process.env.NODE_ENV !== "test") {
    try {
      const server = await build();
      const port = process.env.PORT ? parseInt(process.env.PORT) : 3000;
      await server.listen({ port, host: "0.0.0.0" });
      console.log(`Server is running on port ${port}`);
    } catch (err) {
      console.error("Error starting server:", err);
      process.exit(1);
    }
  }
};

if (process.env.NODE_ENV !== "test") {
  startServer();
}

export default build;

================
File: tests/__mocks__/mockRFIDHandler.ts
================
export const mockRFIDHandler = {
  connect: jest.fn().mockResolvedValue(true),
  disconnect: jest.fn().mockResolvedValue(undefined),
  readData: jest.fn().mockResolvedValue("test-data"),
  writeData: jest.fn().mockResolvedValue(undefined),
};

jest.mock("../server/rfid/V680RFIDHandler", () => {
  return {
    V680RFIDHandler: jest.fn().mockImplementation(() => mockRFIDHandler),
  };
});

================
File: tests/__mocks__/serialport.ts
================
export const mockSerialPort = {
  write: jest.fn().mockImplementation((data, callback) => {
    if (callback) callback();
    return true;
  }),
  on: jest.fn().mockImplementation((event, listener) => {
    if (event === "data") {
      listener(Buffer.from("RD00test-data*"));
    }
    return mockSerialPort;
  }),
  close: jest.fn().mockImplementation((callback) => {
    if (callback) callback();
    return true;
  }),
};

export class SerialPort {
  constructor(options: any) {
    Object.assign(this, mockSerialPort);
  }

  static list = jest.fn().mockResolvedValue([]);
}

export default {
  SerialPort,
};

================
File: tests/__mocks__/V680RFIDHandler.ts
================
export const mockRFIDHandler = {
  connect: jest.fn().mockResolvedValue(true),
  disconnect: jest.fn().mockResolvedValue(undefined),
  readData: jest.fn().mockResolvedValue("test-data"),
  writeData: jest.fn().mockResolvedValue(undefined),
};

export class V680RFIDHandler {
  static instance = mockRFIDHandler;

  constructor() {
    return mockRFIDHandler;
  }
}

================
File: tests/auth.test.ts
================
import { describe, it, expect, beforeEach } from "@jest/globals";
import { app, createTestUser } from "./setup.js";
import prisma from "../server/lib/prisma.js";

describe("Authentication", () => {
  beforeEach(async () => {
    await prisma.user.deleteMany();
    await new Promise((resolve) => setTimeout(resolve, 500));
  }, 15000);

  describe("POST /auth/login", () => {
    it("should authenticate valid user and return token", async () => {
      const user = await createTestUser();

      const response = await app.inject({
        method: "POST",
        url: "/auth/login",
        payload: {
          username: user.username,
          password: "password123",
        },
      });

      expect(response.statusCode).toBe(200);
      const { token, refreshToken } = JSON.parse(response.payload);
      expect(token).toBeDefined();
      expect(refreshToken).toBeDefined();
    }, 15000);

    it("should reject invalid credentials", async () => {
      const user = await createTestUser();

      const response = await app.inject({
        method: "POST",
        url: "/auth/login",
        payload: {
          username: user.username,
          password: "wrongpassword",
        },
      });

      expect(response.statusCode).toBe(401);
    }, 15000);
  });
});

================
File: tests/rfid.test.ts
================
import { describe, it, expect, beforeEach } from "@jest/globals";
import { app, getAuthToken } from "./setup.js";
import { mockSerialPort } from "./__mocks__/serialport.js";

jest.mock("serialport");

jest.setTimeout(60000);

describe("RFID Operations", () => {
  let authToken: string;

  beforeEach(async () => {
    jest.clearAllMocks();

    mockSerialPort.write = jest.fn().mockImplementation((data, callback) => {
      if (callback) callback();
      return true;
    });

    mockSerialPort.on = jest.fn().mockImplementation((event, listener) => {
      if (event === "data") {
        listener(Buffer.from("RD00test-data*"));
      }
      return mockSerialPort;
    });

    authToken = await getAuthToken();
  });

  it("should reject unauthorized requests", async () => {
    const response = await app.inject({
      method: "POST",
      url: "/api/rfid/read",
      payload: {
        tagId: "test-tag",
      },
    });

    expect(response.statusCode).toBe(401);
  });

  it("should write data to RFID tag when authenticated", async () => {
    mockSerialPort.on = jest.fn().mockImplementation((event, listener) => {
      if (event === "data") {
        listener(Buffer.from("WT00*"));
      }
      return mockSerialPort;
    });

    const response = await app.inject({
      method: "POST",
      url: "/api/rfid/write",
      headers: {
        Authorization: `Bearer ${authToken}`,
      },
      payload: {
        tagId: "test-tag",
        data: "54321",
      },
    });

    expect(response.statusCode).toBe(200);
    expect(mockSerialPort.write).toHaveBeenCalled();
  });

  it("should handle RFID write errors gracefully", async () => {
    mockSerialPort.write = jest.fn().mockImplementation((data, callback) => {
      if (callback) callback(new Error("Write failed"));
      return false;
    });

    const response = await app.inject({
      method: "POST",
      url: "/api/rfid/write",
      headers: {
        Authorization: `Bearer ${authToken}`,
      },
      payload: {
        tagId: "test-tag",
        data: "54321",
      },
    });

    expect(response.statusCode).toBe(500);
    expect(JSON.parse(response.payload)).toEqual({
      message: "Error writing to RFID tag",
    });
  });

  it("should read RFID tag data when authenticated", async () => {
    mockSerialPort.on = jest.fn().mockImplementation((event, listener) => {
      if (event === "data") {
        listener(Buffer.from("RD00test-data*"));
      }
      return mockSerialPort;
    });

    const response = await app.inject({
      method: "POST",
      url: "/api/rfid/read",
      headers: {
        Authorization: `Bearer ${authToken}`,
      },
      payload: {
        tagId: "test-tag",
      },
    });

    expect(response.statusCode).toBe(200);
    const payload = JSON.parse(response.payload);
    expect(payload.data).toBeDefined();
  });
});

================
File: tests/setup.ts
================
import { PrismaClient } from "@prisma/client";
import bcrypt from "bcrypt";
import { FastifyInstance } from "fastify";
import build from "../server/server.js";

jest.mock("serialport");

const prisma = new PrismaClient();
let app: FastifyInstance;

beforeAll(async () => {
  app = await build();
});

afterAll(async () => {
  await app.close();
  await prisma.$disconnect();
});

export const cleanupTestUsers = async (): Promise<void> => {
  try {
    await prisma.user.deleteMany({
      where: {
        OR: [
          { username: { startsWith: "testuser" } },
          { email: { endsWith: "@example.com" } },
        ],
      },
    });
    await new Promise((resolve) => setTimeout(resolve, 500));
  } catch (error) {
    console.error("Error cleaning up test users:", error);
  }
};

let testUserCounter = 0;

export const createTestUser = async () => {
  try {
    await cleanupTestUsers();

    const uniqueSuffix = Date.now() + testUserCounter++;
    const hashedPassword = await bcrypt.hash("password123", 10);

    const user = await prisma.user.create({
      data: {
        username: `testuser${uniqueSuffix}`,
        email: `test${uniqueSuffix}@example.com`,
        password: hashedPassword,
        resetToken: null,
        resetTokenExpiry: null,
      },
    });

    return user;
  } catch (error) {
    console.error("Error creating test user:", error);
    throw error;
  }
};

export const getAuthToken = async (): Promise<string> => {
  const user = await createTestUser();
  const response = await app.inject({
    method: "POST",
    url: "/auth/login",
    payload: {
      username: user.username,
      password: "password123",
    },
  });

  const { token } = JSON.parse(response.payload);
  return token;
};

export { app };

================
File: .gitignore
================
# General
.DS_Store
.AppleDouble
.LSOverride

# Icon must end with two \r
Icon

# Thumbnails
._*

# Files that might appear in the root of a volume
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent

# Directories potentially created on remote AFP share
.AppleDB
.AppleDesktop
Network Trash Folder
Temporary Items
.apdisk


# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*
.env

================
File: global_rate_test.sh
================
#!/bin/bash
for i in {1..110}; do
  curl -X GET http://localhost:3000/
  echo "Request $i"
done

================
File: jest.config.js
================
export default {
  preset: 'ts-jest/presets/default-esm',
  testEnvironment: 'node',
  extensionsToTreatAsEsm: ['.ts'],
  moduleNameMapper: {
    '^(\\.{1,2}/.*)\\.js$': '$1',
    '^(\\.{1,2}/.*)\\.ts$': '$1'
  },
  transform: {
    '^.+\\.tsx?$': [
      'ts-jest',
      {
        useESM: true,
        tsconfig: {
          target: 'ES2022',
          module: 'ESNext'
        }
      },
    ],
  },
  setupFilesAfterEnv: ['<rootDir>/tests/setup.ts'],
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'],
  testMatch: ['**/*.test.ts'],
  collectCoverageFrom: [
    'server/**/*.ts',
    '!server/**/*.d.ts'
  ],
  testTimeout: 60000,
  moduleDirectories: ['node_modules', '<rootDir>'],
  slowTestThreshold: 30
};

================
File: nodemon.json
================
{
  "watch": ["server"],
  "ext": ".ts,.js",
  "ignore": ["node_modules"],
  "exec": "node --loader ts-node/esm server/server.ts"
}

================
File: openapi.yml
================
openapi: 3.0.0
info:
  title: RFID Management System API
  version: 1.0.0
  description: API for managing RFID tags and user authentication

servers:
  - url: http://localhost:3000
    description: Development server

components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT

  schemas:
    User:
      type: object
      properties:
        id:
          type: integer
        username:
          type: string
        email:
          type: string
        companyName:
          type: string
          nullable: true
        branch:
          type: string
          nullable: true
        division:
          type: string
          nullable: true
        title:
          type: string
          nullable: true
        telephoneNumber:
          type: string
          nullable: true

    LoginRequest:
      type: object
      required:
        - username
        - password
      properties:
        username:
          type: string
        password:
          type: string

    LoginResponse:
      type: object
      properties:
        token:
          type: string
        refreshToken:
          type: string
        user:
          $ref: '#/components/schemas/User'

    RegisterRequest:
      type: object
      required:
        - username
        - email
        - password
      properties:
        username:
          type: string
        email:
          type: string
          format: email
        password:
          type: string
          minLength: 6
        companyName:
          type: string
        branch:
          type: string
        division:
          type: string
        title:
          type: string
        telephoneNumber:
          type: string

    ForgotPasswordRequest:
      type: object
      required:
        - email
      properties:
        email:
          type: string
          format: email

    ResetPasswordRequest:
      type: object
      required:
        - token
        - newPassword
      properties:
        token:
          type: string
        newPassword:
          type: string
          minLength: 6

    RefreshTokenRequest:
      type: object
      required:
        - refreshToken
      properties:
        refreshToken:
          type: string

    RFIDReadRequest:
      type: object
      required:
        - tagId
      properties:
        tagId:
          type: string

    RFIDWriteRequest:
      type: object
      required:
        - tagId
        - data
      properties:
        tagId:
          type: string
        data:
          type: string

    Error:
      type: object
      properties:
        error:
          type: string
        message:
          type: string

paths:
  /login:
    post:
      summary: Authenticate user and get tokens
      tags:
        - Authentication
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/LoginRequest'
      responses:
        '200':
          description: Successful login
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/LoginResponse'
        '401':
          description: Invalid credentials
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'

  /register:
    post:
      summary: Register a new user
      tags:
        - Authentication
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/RegisterRequest'
      responses:
        '200':
          description: User registered successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'
        '409':
          description: Username or email already exists
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'

  /forgot-password:
    post:
      summary: Request password reset
      tags:
        - Authentication
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ForgotPasswordRequest'
      responses:
        '200':
          description: Password reset email sent
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string

  /reset-password:
    post:
      summary: Reset password using token
      tags:
        - Authentication
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ResetPasswordRequest'
      responses:
        '200':
          description: Password reset successful
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
        '400':
          description: Invalid or expired token
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'

  /refresh-token:
    post:
      summary: Get new access token using refresh token
      tags:
        - Authentication
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/RefreshTokenRequest'
      responses:
        '200':
          description: New access token generated
          content:
            application/json:
              schema:
                type: object
                properties:
                  token:
                    type: string
        '401':
          description: Invalid refresh token
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'

  /read:
    post:
      summary: Read data from RFID tag
      tags:
        - RFID
      security:
        - bearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/RFIDReadRequest'
      responses:
        '200':
          description: Data read successfully
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: string
                  user:
                    $ref: '#/components/schemas/User'
        '500':
          description: Error reading RFID tag
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'

  /write:
    post:
      summary: Write data to RFID tag
      tags:
        - RFID
      security:
        - bearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/RFIDWriteRequest'
      responses:
        '200':
          description: Data written successfully
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                  user:
                    $ref: '#/components/schemas/User'
        '500':
          description: Error writing to RFID tag
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'

================
File: package.json
================
{
  "name": "rfid-management-system",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "description": "RFID Management System with Fastify and PostgreSQL",
  "main": "dist/server/server.js",
  "engines": {
    "node": "22.x"
  },
  "scripts": {
    "dev": "tsx watch server/server.ts",
    "start": "node dist/server/server.js",
    "build": "tsc",
    "prisma:studio": "npx prisma studio",
    "prisma:migrate": "npx prisma migrate dev",
    "test": "jest --config jest.config.js",
    "test:watch": "jest --config jest.config.js --watch",
    "test:coverage": "jest --config jest.config.js --coverage",
    "generate:api-types": "openapi --input ./openapi.yml --output ./ClientApp/src/types/api --client axios --name RFIDApi",
    "heroku-postbuild": "npm install --save typescript @types/node @types/bcrypt @types/nodemailer @types/pg && cd ClientApp && npm install && npm run build && cd .. && tsc && npx prisma generate"
  },
  "dependencies": {
    "@fastify/cors": "^8.5.0",
    "@fastify/formbody": "^7.4.0",
    "@fastify/jwt": "^8.0.0",
    "@fastify/rate-limit": "^9.1.0",
    "@fastify/static": "^7.0.0",
    "@fastify/swagger": "^8.14.0",
    "@fastify/swagger-ui": "^3.0.0",
    "@prisma/client": "^5.10.0",
    "@types/bcrypt": "^5.0.2",
    "@types/node": "^20.11.24",
    "@types/nodemailer": "^6.4.14",
    "@types/pg": "^8.11.2",
    "bcrypt": "^5.1.1",
    "dotenv": "^16.4.5",
    "fastify": "^4.26.0",
    "fastify-plugin": "^4.5.1",
    "nodemailer": "^6.9.11",
    "pg": "^8.11.3",
    "pino": "^8.19.0",
    "pino-pretty": "^10.3.1",
    "prisma": "^5.10.0",
    "serialport": "^12.0.0",
    "typescript": "^5.3.3"
  },
  "devDependencies": {
    "@babel/preset-env": "^7.26.0",
    "@types/jest": "^29.5.12",
    "@typescript-eslint/eslint-plugin": "^7.1.0",
    "@typescript-eslint/parser": "^7.1.0",
    "eslint": "^8.57.0",
    "jest": "^29.7.0",
    "jest-mock-extended": "^3.0.5",
    "nodemon": "^3.1.0",
    "openapi-typescript-codegen": "^0.29.0",
    "ts-jest": "^29.1.2",
    "ts-node": "^10.9.2",
    "tsx": "^4.7.1"
  },
  "packageManager": "npm@10.8.3"
}

================
File: password_reset_test.sh
================
#!/bin/bash
for i in {1..7}; do
  curl -X POST -H "Content-Type: application/json" -d '{"email":"test@example.com"}' http://localhost:3000/auth/forgot-password
  echo "Request $i"
done

================
File: README.md
================
# RFID タグライター Web アプリケーション

Web Serial API を使用して RFID タグの読み取りと書き込みを行う Web アプリケーションです。React、Fastify、Prisma で構築されています。

## 環境設定

### 前提条件

- Node.js 20.13.1 (nodenv の使用を推奨)
- PostgreSQL
- RFID リーダーハードウェア (V680-CH1D 互換)

### インストール

1. nodenv を使用して Node.js をインストール:

```
nodenv install 20.13.1
```

2. パッケージをインストール:

```shell
npm install
```

3. サーバーを起動:

```
npm run dev
```

### データベース設定

1. Heroku PostgreSQL データベースの確認:

```bash
# データベース情報を表示
heroku pg:info

# データベースに接続
heroku pg:psql
```

2. 便利なデータベースコマンド:

```bash
# テーブル一覧を表示
\dt

# psqlを終了
\q
```

3. Prisma マイグレーションの実行:

```bash
# Herokuでマイグレーションを実行
heroku run npx prisma migrate deploy

# Prisma Clientを生成
npx prisma generate
```

## 開発

### フロントエンド開発

フロントエンドは React と Vite を使用して構築されており、以下を含みます:

- ユーザー認証システム
- RFID タグの読み取り/書き込みインターフェース
- リアルタイムのステータス更新
- エラーハンドリングと通知

### バックエンド開発

バックエンドは以下を使用しています:

- Fastify をサーバーとして使用
- Prisma をデータベース管理に使用
- JWT を認証に使用
- API 保護のためのレート制限
- API ドキュメントのための OpenAPI/Swagger

### API ドキュメント

開発サーバー実行時、API ドキュメントは以下で利用可能:
http://localhost:3000/documentation

## プロジェクト構造

```
├── ClientApp/          # Reactフロントエンドアプリケーション
├── server/            # Fastifyバックエンドサーバー
├── prisma/            # データベーススキーマとマイグレーション
├── tests/             # テストファイル
└── openapi.yml        # APIドキュメント
```

## テスト

テストを実行:

```bash
npm run test
```

テストカバレッジを確認:

```bash
npm run test:coverage
```

## ハードウェア要件

- V680-CH1D RFID リーダーと互換性があること
- シリアルポートで接続
- Web Serial API をサポートするブラウザ (Chrome 89+または Edge 89+)

## スクリプト

- `npm run dev` - 開発サーバーを起動
- `npm run build` - プロダクション用にビルド
- `npm run start` - プロダクションサーバーを起動
- `npm run test` - テストを実行
- `npm run generate:api-types` - OpenAPI 仕様から API タイプを生成

---

---

# RFID Tag Writer Web Application

A web application for reading and writing RFID tags using Web Serial API. Built with React, Fastify, and Prisma.

## Environment Setup

### Prerequisites

- Node.js 20.13.1 (recommended to use nodenv)
- PostgreSQL
- RFID Reader Hardware (V680-CH1D compatible)

### Installation

1. Install Node.js using nodenv:

```
nodenv install 20.13.1
```

2. Install packages:

```shell
npm install
```

3. Start the server:

```
npm run dev
```

### Database Setup

1. Check your Heroku PostgreSQL database:

```bash
# View database info
heroku pg:info

# Connect to database
heroku pg:psql
```

2. Useful database commands:

```bash
# List all tables
\dt

# Exit psql
\q
```

3. Run Prisma migrations:

```bash
# Deploy migrations on Heroku
heroku run npx prisma migrate deploy

# Generate Prisma Client
npx prisma generate
```

## Development

### Frontend Development

The frontend is built using React with Vite and includes:

- User authentication system
- RFID tag reading/writing interface
- Real-time status updates
- Error handling and notifications

### Backend Development

The backend uses:

- Fastify for the server
- Prisma for database management
- JWT for authentication
- Rate limiting for API protection
- OpenAPI/Swagger for API documentation

### API Documentation

When running the development server, API documentation is available at:
http://localhost:3000/documentation

## Project Structure

```
├── ClientApp/          # React frontend application
├── server/            # Fastify backend server
├── prisma/            # Database schema and migrations
├── tests/             # Test files
└── openapi.yml        # API documentation
```

## Testing

Run tests using:

```bash
npm run test
```

For test coverage:

```bash
npm run test:coverage
```

## Hardware Requirements

- Compatible with V680-CH1D RFID reader
- Connected via Serial port
- Web Serial API supported browser (Chrome 89+ or Edge 89+)

## Scripts

- `npm run dev` - Start development server
- `npm run build` - Build for production
- `npm run start` - Start production server
- `npm run test` - Run tests
- `npm run generate:api-types` - Generate API types from OpenAPI spec

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "outDir": "./dist",
    "rootDir": ".",
    "baseUrl": ".",
    "paths": {
      "*": ["node_modules/*"]
    },
    "typeRoots": [
      "./node_modules/@types",
      "./types"
    ],
    "types": ["node"],
    "allowJs": true,
    "checkJs": false,
    "resolveJsonModule": true
  },
  "include": [
    "server/**/*",
    "types/**/*",
    "node_modules/@types/**/*"
  ],
  "exclude": ["node_modules", "ClientApp", "tests", "dist"]
}

================
File: tsconfig.node.json
================
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}

================
File: types.d.ts
================
import "@fastify/jwt";
import { hash, compare } from "bcrypt";
import { FastifyRequest, FastifyReply } from "fastify";

declare module "fastify" {
  interface FastifyInstance {
    authenticate: (
      request: FastifyRequest,
      reply: FastifyReply
    ) => Promise<void>;
    bcrypt: {
      hash: typeof hash;
      compare: typeof compare;
    };
  }
}

declare module "@fastify/jwt" {
  interface FastifyJWT {
    payload: {
      id: number;
      username: string;
      email: string;
      companyName?: string | null;
      branch?: string | null;
      division?: string | null;
      title?: string | null;
      telephoneNumber?: string | null;
    };
    user: {
      id: number;
      username: string;
      email: string;
      companyName?: string | null;
      branch?: string | null;
      division?: string | null;
      title?: string | null;
      telephoneNumber?: string | null;
    };
  }
}
